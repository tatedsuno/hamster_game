<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hamster Adventure Farm Update</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e272e;
            font-family: sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* UI Layer */
        .ui-layer {
            position: absolute; pointer-events: none; z-index: 10;
            width: 100%; height: 100%; top: 0; left: 0;
        }
        .ui-text {
            position: absolute; right: 20px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; text-align: right;
        }
        #score { top: 20px; font-size: 24px; color: #00d8d6; }
        #seedCount { top: 50px; font-size: 24px; color: #feca57; }
        #flickHint {
            top: 85px; font-size: 16px; color: #fff; opacity: 0.8;
            background-color: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px;
        }
        
        /* Buttons & Inputs */
        .btn {
            pointer-events: auto; background-color: #fff; border: 2px solid #333;
            border-radius: 8px; padding: 10px 20px; font-weight: bold; font-size: 16px;
            cursor: pointer; box-shadow: 0 4px 0 #999; margin: 5px;
        }
        .btn:active { box-shadow: 0 2px 0 #999; transform: translateY(2px); }
        .btn:disabled {
            background-color: #ccc; color: #666; cursor: not-allowed;
            box-shadow: none; transform: none;
        }

        /* Modals */
        .modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9); padding: 20px; border-radius: 15px;
            text-align: center; color: #fff; z-index: 80; display: none;
            width: 85%; max-width: 350px; border: 2px solid #fff;
        }

        /* Nest UI */
        #nestUI {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 500px; background-color: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 15px; text-align: center; z-index: 50;
            display: none; box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
        }
        #nestStats { font-size: 16px; margin-bottom: 10px; color: #2d3436; text-align: left; padding: 0 10px; }
        .breed-info { font-size: 14px; color: #d63031; font-weight: bold; }
        .slider-container { margin: 10px 0; text-align: left; padding: 0 10px; }
        input[type=range] { width: 100%; }
        .action-area { display: flex; justify-content: space-between; gap: 10px; }
        .action-area button { flex: 1; }

        /* Field UI */
        #fieldUI {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #5d4037; z-index: 40; display: none;
            overflow-y: auto; padding-top: 60px;
        }
        #fieldHeader {
            position: absolute; top: 0; left: 0; width: 100%; height: 50px;
            background: rgba(0,0,0,0.5); color: #fff; line-height: 50px;
            text-align: center; font-size: 20px; font-weight: bold; z-index: 45;
        }
        .field-grid {
            display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px;
            padding: 10px; margin-bottom: 100px;
        }
        .field-slot {
            aspect-ratio: 1; background-color: #3e2723; border: 2px solid #795548;
            border-radius: 5px; position: relative; display: flex;
            justify-content: center; align-items: center; font-size: 24px;
            cursor: pointer;
        }
        .field-slot.locked { background-color: #2b1d19; border-color: #3e2723; opacity: 0.5; }
        .slot-info { font-size: 10px; position: absolute; bottom: 2px; color: #fff; width: 100%; text-align: center;}

        /* Shop Button in Nest */
        #shopBtnContainer { position: absolute; top: -50px; right: 10px; }
        
        #instruction {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: #fff; text-shadow: 2px 2px 0 #000;
            pointer-events: none; text-align: center; z-index: 20;
            background-color: rgba(0, 0, 0, 0.5); padding: 20px; border-radius: 10px; width: 80%;
        }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1e272e; color: #fff; display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loading">Loading...</div>

<div class="ui-layer" id="gameUI">
    <div id="score" class="ui-text">Distance: 0m</div>
    <div id="seedCount" class="ui-text">Seeds: 0 / 100</div>
    <div id="flickHint" class="ui-text">â† ãƒ•ãƒªãƒƒã‚¯ã§å¸°å·£</div>
</div>

<canvas id="gameCanvas"></canvas>
<div id="instruction" style="display:none;">ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</div>

<div id="pauseModal" class="modal">
    <h3>ğŸ  å¸°ã‚Šã¾ã™ã‹ï¼Ÿ</h3>
    <p>ä»Šã®ä»²é–“ã¨ç¨®ã‚’æŒã£ã¦<br>å·£ã«å¸°ã‚Šã¾ã™ã€‚</p>
    <button class="btn" style="background:#ff9f43; color:#fff;" onclick="confirmGoHome()">ã¯ã„ (å¸°ã‚‹)</button>
    <button class="btn" onclick="cancelGoHome()">ã„ã„ãˆ (æˆ»ã‚‹)</button>
</div>

<div id="breedingModal" class="modal">
    <h3>ğŸ’– å®¶æ—ã‚’å¢—ã‚„ã—ã¾ã™ã‹ï¼Ÿ</h3>
    <p style="text-align:left; display:inline-block;">
        <span style="color:#feca57">ğŸŒ» æ¶ˆè²»: ç¨® 600å€‹</span><br>
        <span style="color:#ff9f43">ğŸ¹ è¦ª: 1åŒ¹</span><br>
        <span style="font-size:12px; color:#aaa;">â€»è¦ªã¯è‚²å…ã®ãŸã‚å†’é™ºã«å‡ºã‚‰ã‚Œãªããªã‚Šã¾ã™</span>
    </p>
    <br><br>
    <button class="btn" style="background:#fd79a8; color:#fff;" onclick="confirmBreeding()">ã¯ã„ (ç¹æ®–ã™ã‚‹)</button>
    <button class="btn" onclick="cancelBreeding()">ã„ã„ãˆ (ã‚„ã‚ã‚‹)</button>
</div>

<div id="gameOverModal" class="modal">
    <div id="overlayText"></div>
    <br>
    <button class="btn" onclick="resetGame(selectedFriendsCount)">ãƒªãƒˆãƒ©ã‚¤</button>
    <br><br>
    <button class="btn" onclick="initNest()">å·£ã«æˆ»ã‚‹</button>
</div>

<div id="logModal" class="modal">
    <h3>ğŸ“ å†’é™ºæ—¥èªŒ</h3>
    <div id="logContent" style="text-align: left; margin: 10px 0; font-size: 14px; max-height:200px; overflow-y:auto;"></div>
    <button class="btn" onclick="closeLog()">é–‰ã˜ã‚‹</button>
</div>

<div id="shopModal" class="modal">
    <h3>ğŸ›’ ãƒãƒ ã‚·ãƒ§ãƒƒãƒ—</h3>
    <div id="shopContent" style="text-align:left; margin-bottom:15px;"></div>
    <button class="btn" onclick="closeShop()">é–‰ã˜ã‚‹</button>
</div>

<div id="nestUI">
    <div id="shopBtnContainer" style="display:none;">
        <button class="btn" style="background:#54a0ff; color:#fff; font-size:14px; padding:5px 10px;" onclick="openShop()">ğŸ›’ ã‚·ãƒ§ãƒƒãƒ—</button>
    </div>
    <div id="nestStats">
        <div>ğŸŒ» è²¯è”µç¨®: <b id="bankSeeds" style="color:#e67e22; font-size:20px;">0</b> å€‹</div>
        <div>ğŸ¹ å¤§äºº: <b id="bankFriends">0</b> åŒ¹ / ğŸ‘¶ å­ãƒãƒ : <b id="babyCount">0</b> åŒ¹</div>
        <div id="pregnantInfo" class="breed-info"></div>
    </div>
    <div style="font-size:12px; color:#aaa; margin-bottom:5px;">ğŸ‘‰ å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§ç•‘ã¸</div>
    <hr>
    <div class="slider-container">
        <label>é€£ã‚Œã¦è¡Œã: <b id="takeCount">0</b> åŒ¹</label>
        <input type="range" id="friendSlider" min="0" max="0" value="0" oninput="updateSlider()">
    </div>
    <div class="action-area">
        <button id="breedBtn" class="btn" style="background:#fd79a8; color:#fff;" onclick="startBreedingCheck()">ğŸ’– ç¹æ®–</button>
        <button class="btn" style="background:#00cec9; color:#fff;" onclick="departFromNest()">å†’é™ºã¸ï¼</button>
    </div>
</div>

<div id="fieldUI">
    <div id="fieldHeader">ğŸŒ» ã²ã¾ã‚ã‚Šç•‘ <span style="font-size:12px; font-weight:normal;">(â†ã‚¹ãƒ¯ã‚¤ãƒ—ã§å·£ã¸)</span></div>
    <div style="text-align:center; color:#feca57; margin-top:10px;">æ‰€æŒ: <span id="fieldSeeds">0</span> Seeds</div>
    <div id="fieldGrid" class="field-grid"></div>
    <div style="text-align:center; color:#ccc; font-size:12px; padding:20px;">
        ç¨®ã‚’æ¤ãˆã‚‹ã¨3å›ã®å†’é™ºå¾Œã«åç©«ã§ãã¾ã™ã€‚<br>(1ç²’ â†’ 10ç²’)
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // â–¼â–¼â–¼ ç”»åƒèª­ã¿è¾¼ã¿ â–¼â–¼â–¼
    const sprites = {
        idle: { img: new Image(), loaded: false },
        run: { img: new Image(), loaded: false },
        jump: { img: new Image(), loaded: false },
        djump: { img: new Image(), loaded: false },
        fall: { img: new Image(), loaded: false },
        seed: { img: new Image(), loaded: false }
    };
    sprites.idle.img.src = 'ham.idle.png';
    sprites.run.img.src = 'ham.run.png';
    sprites.jump.img.src = 'ham.jump.png';
    sprites.djump.img.src = 'ham.djump.png';
    sprites.fall.img.src = 'ham.fall.png';
    sprites.seed.img.src = 'seed.png';

    let imagesLoadedCount = 0;
    const totalImages = Object.keys(sprites).length;
    let gameStarted = false;

    function checkAllImagesLoaded() {
        imagesLoadedCount++;
        if (imagesLoadedCount >= totalImages) startGame();
    }
    for (let key in sprites) {
        sprites[key].img.onload = () => { sprites[key].loaded = true; checkAllImagesLoaded(); };
        sprites[key].img.onerror = () => { console.warn("Load failed: " + sprites[key].img.src); sprites[key].loaded = false; checkAllImagesLoaded(); };
    }
    setTimeout(() => { if (!gameStarted) startGame(); }, 3000);

    function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        document.getElementById('loading').style.display = 'none';
        if (localStorage.getItem('ham_seeds')) initNest(); else initNest();
    }

    // ==========================================
    // â–¼â–¼â–¼ è¨­å®š & ãƒ‡ãƒ¼ã‚¿ç®¡ç† â–¼â–¼â–¼
    // ==========================================
    const ZOOM_SCALE = 0.6; 
    const FRIEND_INTERVAL_METER = 200; 
    const NEST_FLOOR_OFFSET = 650; 
    const MAX_PHYSICS_SEEDS = 200;
    const SEED_CAPACITY_PER_HAMSTER = 100;
    const BREEDING_COST_SEEDS = 600;
    const BABIES_PER_BIRTH = 6;
    const FIELD_GROWTH_TRIPS = 3; // åç©«ã¾ã§ã®å†’é™ºå›æ•°

    // ç”»é¢ã‚µã‚¤ã‚ºèª¿æ•´
    function resize() {
        const sw = window.innerWidth; const sh = window.innerHeight;
        canvas.width = sw / ZOOM_SCALE; canvas.height = sh / ZOOM_SCALE;
    }
    window.addEventListener('resize', resize);
    resize();

    // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿
    let gameState = 'loading'; // loading, nest, field, playing, paused, gameover
    let bankSeeds = parseInt(localStorage.getItem('ham_seeds') || '0');
    let bankFriends = parseInt(localStorage.getItem('ham_friends') || '0');
    let breedingQueue = JSON.parse(localStorage.getItem('ham_breeding') || '[]');
    
    // æ–°æ©Ÿèƒ½ç”¨ãƒ‡ãƒ¼ã‚¿
    let shopUnlocked = (localStorage.getItem('ham_shopUnlocked') === 'true');
    let fieldLevel = parseInt(localStorage.getItem('ham_fieldLevel') || '0'); // 0:æœªé–‹æ”¾, 1~:åˆ—æ•°
    let fieldData = JSON.parse(localStorage.getItem('ham_fieldData') || '[]'); 
    // fieldData example: [{state:0, progress:0}, ...] (state: 0=empty, 1=planted)
    
    let selectedFriendsCount = 0; 

    function saveData() {
        localStorage.setItem('ham_seeds', bankSeeds);
        localStorage.setItem('ham_friends', bankFriends);
        localStorage.setItem('ham_breeding', JSON.stringify(breedingQueue));
        localStorage.setItem('ham_shopUnlocked', shopUnlocked);
        localStorage.setItem('ham_fieldLevel', fieldLevel);
        localStorage.setItem('ham_fieldData', JSON.stringify(fieldData));
    }

    // ==========================================
    // â–¼â–¼â–¼ ç•‘ (Field) ã‚·ã‚¹ãƒ†ãƒ  â–¼â–¼â–¼
    // ==========================================
    function initFieldData() {
        // ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸã‚¹ãƒ­ãƒƒãƒˆæ•°ã‚’ç¢ºä¿ (1åˆ—6å€‹)
        const totalSlots = fieldLevel * 6;
        while(fieldData.length < totalSlots) {
            fieldData.push({ state: 0, progress: 0 }); // state:0=ç©º, 1=è‚²æˆä¸­, 2=åç©«å¯
        }
    }

    function openField() {
        gameState = 'field';
        document.getElementById('nestUI').style.display = 'none';
        document.getElementById('fieldUI').style.display = 'block';
        updateFieldUI();
    }

    function closeField() {
        gameState = 'nest';
        document.getElementById('fieldUI').style.display = 'none';
        initNest(); // å·£ã«æˆ»ã‚‹
    }

    function updateFieldUI() {
        document.getElementById('fieldSeeds').innerText = bankSeeds;
        const grid = document.getElementById('fieldGrid');
        grid.innerHTML = '';

        if (fieldLevel === 0) {
            grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:#aaa; padding:50px;">ç•‘ã¯ã¾ã è’ã‚Œåœ°ã§ã™ã€‚<br>ã‚·ãƒ§ãƒƒãƒ—ã§é–‹å¢¾ã—ã¾ã—ã‚‡ã†ã€‚</div>';
            return;
        }

        initFieldData();

        fieldData.forEach((slot, idx) => {
            const div = document.createElement('div');
            div.className = 'field-slot';
            
            if (slot.state === 0) {
                // ç©ºãåœ°
                div.innerHTML = ''; 
                div.onclick = () => plantSeed(idx);
            } else if (slot.state === 1) {
                // è‚²æˆä¸­
                let icon = 'ğŸŒ±';
                if (slot.progress >= 1) icon = 'ğŸŒ¿';
                if (slot.progress >= 2) icon = 'ğŸŒ³'; 
                div.innerHTML = `${icon}<div class="slot-info">ã‚ã¨${FIELD_GROWTH_TRIPS - slot.progress}å›</div>`;
            } else if (slot.state === 2) {
                // åç©«å¯èƒ½
                div.innerHTML = 'ğŸŒ»<div class="slot-info" style="color:#ff0;">åç©«!</div>';
                div.style.borderColor = '#ffd700';
                div.onclick = () => harvest(idx);
            }
            grid.appendChild(div);
        });
    }

    function plantSeed(idx) {
        if (bankSeeds < 1) { alert("ç¨®ãŒã‚ã‚Šã¾ã›ã‚“ï¼"); return; }
        bankSeeds -= 1;
        fieldData[idx].state = 1;
        fieldData[idx].progress = 0;
        saveData();
        updateFieldUI();
    }

    function harvest(idx) {
        bankSeeds += 10;
        fieldData[idx].state = 0;
        fieldData[idx].progress = 0;
        saveData();
        updateFieldUI();
        // æ¼”å‡ºç”¨
        alert("ç¨®ã‚’10å€‹åç©«ã—ã¾ã—ãŸï¼");
    }

    function processFieldGrowth() {
        // å†’é™ºã‹ã‚‰å¸°ã‚‹ãŸã³ã«å‘¼ã³å‡ºã™
        let grew = false;
        fieldData.forEach(slot => {
            if (slot.state === 1) {
                slot.progress++;
                if (slot.progress >= FIELD_GROWTH_TRIPS) {
                    slot.state = 2; // åç©«å¯èƒ½ã¸
                }
                grew = true;
            }
        });
        if (grew) saveData();
        return grew;
    }

    // ==========================================
    // â–¼â–¼â–¼ ã‚·ãƒ§ãƒƒãƒ— (Shop) ã‚·ã‚¹ãƒ†ãƒ  â–¼â–¼â–¼
    // ==========================================
    function openShop() {
        const modal = document.getElementById('shopModal');
        const content = document.getElementById('shopContent');
        content.innerHTML = '';

        // å•†å“1: ç•‘é–‹æ”¾ (Level 0 -> 1)
        if (fieldLevel === 0) {
            content.innerHTML += `
                <div style="margin-bottom:10px; border:1px solid #555; padding:10px; border-radius:5px;">
                    <b>ğŸšœ ç•‘ã‚’é–‹å¢¾ã™ã‚‹</b><br>
                    <span style="color:#feca57">ä¾¡æ ¼: 1000 Seeds</span><br>
                    <button class="btn" onclick="buyFieldUnlock()">è³¼å…¥ã™ã‚‹</button>
                </div>
            `;
        } else {
            // å•†å“2: ç•‘æ‹¡å¼µ
            let cost = 1000 * (fieldLevel + 1); // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã”ã¨ã«é«˜ããªã‚‹
            content.innerHTML += `
                <div style="margin-bottom:10px; border:1px solid #555; padding:10px; border-radius:5px;">
                    <b>ğŸšœ ç•‘ã‚’åºƒã’ã‚‹ (+1åˆ—)</b><br>
                    <span style="color:#feca57">ä¾¡æ ¼: ${cost} Seeds</span><br>
                    <button class="btn" onclick="buyFieldExpand(${cost})">è³¼å…¥ã™ã‚‹</button>
                </div>
            `;
        }
        
        modal.style.display = 'block';
    }

    function closeShop() { document.getElementById('shopModal').style.display = 'none'; }

    function buyFieldUnlock() {
        if (bankSeeds >= 1000) {
            bankSeeds -= 1000;
            fieldLevel = 1;
            saveData();
            alert("ç•‘ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼\nå³ã«ã‚¹ãƒ¯ã‚¤ãƒ—ã—ã¦è¦‹ã«è¡Œã“ã†ï¼");
            updateNestUI();
            openShop(); // ãƒªãƒ­ãƒ¼ãƒ‰
        } else {
            alert("ç¨®ãŒè¶³ã‚Šã¾ã›ã‚“ï¼");
        }
    }

    function buyFieldExpand(cost) {
        if (bankSeeds >= cost) {
            bankSeeds -= cost;
            fieldLevel++;
            saveData();
            alert("ç•‘ãŒåºƒãŒã‚Šã¾ã—ãŸï¼");
            updateNestUI();
            openShop();
        } else {
            alert("ç¨®ãŒè¶³ã‚Šã¾ã›ã‚“ï¼");
        }
    }

    // ==========================================
    // â–¼â–¼â–¼ ç¹æ®–ãƒ»æ¶ˆè²»ãƒ»æ™‚é–“çµŒé â–¼â–¼â–¼
    // ==========================================
    function startBreedingCheck() {
        // â˜…ä¿®æ­£: å¸¸ã«ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã‚‹ã‚ˆã†ã«ã—ã€æ¡ä»¶åˆ†å²ã§ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‡ºã™
        if (bankSeeds < BREEDING_COST_SEEDS) {
            alert(`ç¨®ãŒè¶³ã‚Šã¾ã›ã‚“ï¼\nå¿…è¦: ${BREEDING_COST_SEEDS}å€‹\nç¾åœ¨: ${bankSeeds}å€‹`);
        } else if (bankFriends < 1) {
            alert("è¦ªã«ãªã‚‹å¤§äººã®ãƒãƒ ã‚¹ã‚¿ãƒ¼ãŒã„ã¾ã›ã‚“ï¼");
        } else {
            document.getElementById('breedingModal').style.display = 'block';
        }
    }

    function confirmBreeding() {
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) {
            bankSeeds -= BREEDING_COST_SEEDS;
            bankFriends -= 1; 
            breedingQueue.push({ type: 'pregnant', tripsRemaining: 1, count: 1 });
            saveData(); updateNestUI();
            nestSeeds.splice(0, Math.min(nestSeeds.length, 50)); 
        }
        closeBreedingModal();
    }
    function cancelBreeding() { document.getElementById('breedingModal').style.display = 'none'; }

    function processTimePassage(collectedSeeds, returnedFriendsCount, foundShopHamster) {
        let log = [];
        bankSeeds += collectedSeeds;
        log.push(`ç¨®ã‚’ ${collectedSeeds} å€‹æŒã¡å¸°ã‚Šã¾ã—ãŸã€‚`);
        
        if (returnedFriendsCount > 0) {
            bankFriends += returnedFriendsCount;
            log.push(`ä»²é–“ ${returnedFriendsCount} åŒ¹ãŒç„¡äº‹ã«å¸°é‚„ã—ã¾ã—ãŸï¼`);
        }

        // ã‚·ãƒ§ãƒƒãƒ—è§£æ”¾ãƒã‚§ãƒƒã‚¯
        if (foundShopHamster && !shopUnlocked) {
            shopUnlocked = true;
            log.push(`<span style="color:#54a0ff; font-weight:bold;">ğŸ‰ ã‚·ãƒ§ãƒƒãƒ—ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’åŠ©ã‘å‡ºã—ãŸï¼<br>ã‚·ãƒ§ãƒƒãƒ—æ©Ÿèƒ½ãŒé–‹æ”¾ã•ã‚Œã¾ã—ãŸï¼</span>`);
        } else if (foundShopHamster) {
            bankFriends++; // ã™ã§ã«é–‹æ”¾æ¸ˆãªã‚‰ãŸã ã®ä»²é–“
            log.push(`è¿·å­ã®ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’é€£ã‚Œå¸°ã‚Šã¾ã—ãŸã€‚`);
        }

        // ç•‘ã®æˆé•·
        if (fieldLevel > 0) {
            if (processFieldGrowth()) {
                log.push(`ğŸŒ» <span style="color:#feca57">ç•‘ã®ã²ã¾ã‚ã‚ŠãŒæˆé•·ã—ã¾ã—ãŸï¼</span>`);
            }
        }

        // ç¹æ®–ãƒ»æ¶ˆè²»
        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        let totalMouths = bankFriends + pregnantCount + babyCount;
        let consumption = totalMouths * 1; 
        log.push(`å·£ã® ${totalMouths} åŒ¹ãŒç¨®ã‚’ ${consumption} å€‹é£Ÿã¹ã¾ã—ãŸã€‚`);

        if (bankSeeds >= consumption) { bankSeeds -= consumption; } else {
            let survivors = bankSeeds; let casualties = totalMouths - survivors;
            bankSeeds = 0; 
            log.push(`<span style="color:red">ç¨®ãŒè¶³ã‚Šãªã„ï¼ ${casualties} åŒ¹ãŒé¤“æ­»ã—ã¾ã—ãŸ...</span>`);
            for (let i = breedingQueue.length - 1; i >= 0; i--) {
                if (casualties <= 0) break; let group = breedingQueue[i];
                if (group.count <= casualties) { casualties -= group.count; breedingQueue.splice(i, 1); }
                else { group.count -= casualties; casualties = 0; }
            }
            if (casualties > 0) { bankFriends = Math.max(0, bankFriends - casualties); }
        }

        let newAdults = 0; let newBabies = 0;
        for (let i = 0; i < breedingQueue.length; i++) {
            let group = breedingQueue[i]; group.tripsRemaining--;
            if (group.tripsRemaining <= 0) {
                if (group.type === 'pregnant') {
                    bankFriends += group.count; let babies = group.count * BABIES_PER_BIRTH; newBabies += babies;
                    group.type = 'baby'; group.count = babies; 
                    group.tripsRemaining = 2; 
                } else if (group.type === 'baby') {
                    newAdults += group.count; bankFriends += group.count; group.done = true; 
                }
            }
        }
        breedingQueue = breedingQueue.filter(q => !q.done);
        if (newBabies > 0) log.push(`ğŸ‘¶ <span style="color:#fd79a8">èµ¤ã¡ã‚ƒã‚“ãŒ ${newBabies} åŒ¹ç”Ÿã¾ã‚Œã¾ã—ãŸï¼</span>`);
        if (newAdults > 0) log.push(`ğŸ¹ <span style="color:#00cec9">å­ãƒãƒ  ${newAdults} åŒ¹ãŒå¤§äººã«ãªã‚Šã¾ã—ãŸï¼</span>`);
        
        saveData(); return log;
    }

    // ==========================================
    // â–¼â–¼â–¼ å·£ (Nest) æç”»ãƒ»ãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
    // ==========================================
    let nestHamsters = []; let nestSeeds = []; 

    class PhysicsSeed {
        constructor(x, y) {
            this.x = x; this.y = y; this.physRadius = 5; 
            this.vx = (Math.random() - 0.5) * 5; this.vy = Math.random() * 5;
            this.rotation = Math.random() * Math.PI * 2; this.sleeping = false; 
        }
        wakeUp() { this.sleeping = false; }
        update() {
            if (this.sleeping) return; 
            this.vy += 0.5; this.x += this.vx; this.y += this.vy;
            this.vx *= 0.95; this.vy *= 0.95;
            let floorY = canvas.height - NEST_FLOOR_OFFSET;
            if (this.y + this.physRadius > floorY) { this.y = floorY - this.physRadius; this.vy *= -0.3; this.vx *= 0.7; }
            if (this.x - 5 < 0) { this.x = 5; this.vx *= -0.5; }
            if (this.x + 5 > canvas.width) { this.x = canvas.width - 5; this.vx *= -0.5; }
            if (Math.abs(this.vx) < 0.05 && Math.abs(this.vy) < 0.1 && this.y > floorY - 10) { this.vx = 0; this.vy = 0; this.sleeping = true; }
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation + this.x * 0.1); 
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, -10, -12, 20, 25);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(0, 0, 10, 12, 0, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        }
    }

    class NestHamster {
        constructor(stage = 0) { 
            this.stage = stage;
            this.x = Math.random() * canvas.width;
            let floorTop = canvas.height - NEST_FLOOR_OFFSET;
            let depthRange = 250; 
            this.y = floorTop + Math.random() * depthRange; 
            this.groundY = this.y; 

            if (this.stage === 2) { this.size = 40; this.state = 'newborn'; } 
            else if (this.stage === 1) { this.size = 65; this.state = 'idle'; } 
            else { this.size = 90; this.state = 'idle'; }

            this.timer = Math.random() * 60; this.vx = 0; this.vy = 0; 
            this.flip = false; this.hopOffset = Math.random() * Math.PI;
            this.isDragging = false; this.isThrown = false; 
        }

        update() {
            if (this.isDragging) return;

            if (this.isThrown || this.y < this.groundY) {
                this.vy += 0.5; this.x += this.vx; this.y += this.vy;
                if (this.y > this.groundY) {
                    this.y = this.groundY; this.vy *= -0.5; this.vx *= 0.8;  
                    if (Math.abs(this.vy) < 1) { this.isThrown = false; this.vy = 0; }
                }
                if (this.x < 0) { this.x = 0; this.vx *= -0.7; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.7; }
                if(Math.abs(this.vx) > 1) this.flip = this.vx < 0;
                this.interactWithSeeds();
                return;
            }
            if (this.stage === 2) return; 

            this.timer--;
            if (this.timer <= 0) {
                if (this.state === 'idle') {
                    this.state = 'move'; this.timer = 10 + Math.random() * 30; 
                    let baseSpeed = (this.stage === 1) ? 6 : 4; 
                    let speed = baseSpeed + Math.random() * 3;
                    this.vx = (Math.random() < 0.5) ? speed : -speed; 
                } else {
                    this.state = 'idle'; this.timer = 20 + Math.random() * 60; this.vx = 0;
                }
            }
            this.x += this.vx;
            if (this.x < 0) { this.x = 0; this.vx *= -1; }
            if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -1; }
            if (this.vx !== 0) this.flip = this.vx < 0; 
            if (this.state === 'move') this.interactWithSeeds();
        }

        interactWithSeeds() {
            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed < 1.0) return;
            for (let s of nestSeeds) {
                let dx = s.x - this.x; let dy = s.y - (this.y - this.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < this.size * 0.6) { 
                    s.wakeUp(); 
                    let angle = Math.atan2(dy, dx); 
                    let kickPower = Math.min(speed * 0.3, 10);
                    s.vx += Math.cos(angle) * kickPower; s.vy += Math.sin(angle) * kickPower - 0.5; 
                }
            }
        }

        draw() {
            let hopY = 0;
            if (!this.isThrown && !this.isDragging) {
                if (this.stage === 2) { if (Math.random() < 0.02) hopY = -5; } 
                else { hopY = (this.state === 'move') ? Math.sin(Date.now() / 20 + this.hopOffset) * 5 : 0; }
            }
            
            ctx.save(); ctx.translate(this.x, this.y - this.size/2 + hopY);
            if (this.isDragging) ctx.scale(1.1, 1.1);
            if (this.flip) ctx.scale(-1, 1);
            
            let img = sprites.idle.loaded ? sprites.idle.img : null;
            if (this.state === 'move' && !this.isDragging && !this.isThrown && sprites.run.loaded) img = sprites.run.img;
            if ((this.isThrown || this.isDragging) && sprites.fall.loaded) img = sprites.fall.img;
            if (this.stage === 2 && sprites.idle.loaded) img = sprites.idle.img;
            
            if (img) ctx.drawImage(img, -this.size/2, -this.size/2, this.size, this.size);
            else { ctx.fillStyle = this.stage === 2 ? '#fab1a0' : '#ff9f43'; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); }
            ctx.restore();
        }
    }

    function initNest() {
        gameState = 'nest';
        document.getElementById('nestUI').style.display = 'block';
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('gameOverModal').style.display = 'none';
        document.getElementById('pauseModal').style.display = 'none';
        document.getElementById('breedingModal').style.display = 'none';
        document.getElementById('instruction').style.display = 'none';
        document.getElementById('fieldUI').style.display = 'none';
        updateNestUI();
        
        nestHamsters = [];
        let displayAdults = Math.min(bankFriends, 30);
        for(let i=0; i<displayAdults; i++) nestHamsters.push(new NestHamster(0)); 
        breedingQueue.forEach(q => {
            if(q.type === 'baby') {
                let stage = q.tripsRemaining; 
                let count = Math.min(q.count, 20);
                for(let i=0; i<count; i++) nestHamsters.push(new NestHamster(stage));
            }
        });
        nestSeeds = [];
        let physicsCount = Math.min(bankSeeds, MAX_PHYSICS_SEEDS);
        for (let i = 0; i < physicsCount; i++) {
            let dropX = (canvas.width / 2) + (Math.random() - 0.5) * 40;
            nestSeeds.push(new PhysicsSeed(dropX, -Math.random() * 500));
        }
        nestLoop();
    }

    function updateNestUI() {
        document.getElementById('bankSeeds').innerText = bankSeeds;
        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        document.getElementById('bankFriends').innerText = bankFriends;
        document.getElementById('babyCount').innerText = babyCount;
        let infoText = ""; if (pregnantCount > 0) infoText += `ğŸ¤° å‡ºç”£å¾…ã¡: ${pregnantCount}åŒ¹ `;
        document.getElementById('pregnantInfo').innerText = infoText;
        
        // ã‚·ãƒ§ãƒƒãƒ—ãƒœã‚¿ãƒ³è¡¨ç¤º
        document.getElementById('shopBtnContainer').style.display = shopUnlocked ? 'block' : 'none';

        const slider = document.getElementById('friendSlider'); slider.max = bankFriends;
        if (parseInt(slider.value) > bankFriends) slider.value = bankFriends;
        updateSlider();
    }

    function nestLoop() {
        if (gameState !== 'nest') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // èƒŒæ™¯
        ctx.fillStyle = '#ffeaa7'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        let floorY = canvas.height - NEST_FLOOR_OFFSET;
        ctx.fillStyle = '#fdcb6e'; ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
        ctx.fillStyle = '#e1b12c'; ctx.fillRect(0, floorY, canvas.width, 10);
        
        let excessSeeds = bankSeeds - nestSeeds.length;
        if (excessSeeds > 0) drawStaticSeedPile(canvas.width / 2, floorY, excessSeeds);
        
        nestSeeds.forEach(s => s.update()); solvePhysics(); nestSeeds.forEach(s => s.draw());
        
        nestHamsters.sort((a, b) => a.y - b.y);
        nestHamsters.forEach(h => { h.update(); h.draw(); });
        
        // Player (Big)
        let mySize = 150; let myY = floorY + 180; 
        ctx.save(); ctx.translate(canvas.width/2 - mySize/2, myY - mySize/2);
        if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, 0, 0, mySize, mySize);
        else { ctx.fillStyle = '#ff3f34'; ctx.fillRect(0, 0, mySize, mySize); }
        ctx.restore();
        
        requestAnimationFrame(nestLoop);
    }

    function drawStaticSeedPile(x, y, count) {
        let scale = Math.min(count / 1000, 3) + 0.5;
        let width = 200 * scale; let height = 80 * scale;
        ctx.fillStyle = '#d4ac0d'; ctx.beginPath(); ctx.ellipse(x, y + 20, width, height, 0, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#9a7d0a'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`+ ${count} Seeds`, x, y - height/2);
    }

    function solvePhysics() {
        const iter = 4; 
        for (let k = 0; k < iter; k++) {
            for (let i = 0; i < nestSeeds.length; i++) {
                let s1 = nestSeeds[i];
                for (let j = i + 1; j < nestSeeds.length; j++) {
                    let s2 = nestSeeds[j];
                    if (s1.sleeping && s2.sleeping) continue;
                    let dx = s2.x - s1.x; let dy = s2.y - s1.y; let distSq = dx*dx + dy*dy; let minDist = s1.physRadius + s2.physRadius; 
                    if (distSq < minDist * minDist && distSq > 0) {
                        let dist = Math.sqrt(distSq); let overlap = minDist - dist;
                        let forceX = (dx / dist) * overlap * 0.5; let forceY = (dy / dist) * overlap * 0.5;
                        s1.x -= forceX; s1.y -= forceY; s2.x += forceX; s2.y += forceY;
                        let avgVx = (s1.vx + s2.vx) * 0.5; let avgVy = (s1.vy + s2.vy) * 0.5;
                        s1.vx = s1.vx * 0.9 + avgVx * 0.1; s1.vy = s1.vy * 0.9 + avgVy * 0.1; s2.vx = s2.vx * 0.9 + avgVx * 0.1; s2.vy = s2.vy * 0.9 + avgVy * 0.1;
                    }
                }
            }
        }
    }

    function updateSlider() {
        const slider = document.getElementById('friendSlider');
        selectedFriendsCount = parseInt(slider.value);
        document.getElementById('takeCount').innerText = selectedFriendsCount;
    }

    function departFromNest() {
        bankFriends -= selectedFriendsCount; saveData();
        document.getElementById('nestUI').style.display = 'none'; document.getElementById('gameUI').style.display = 'block';
        resetGame(selectedFriendsCount);
    }

    // ==========================================
    // â–¼â–¼â–¼ ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (Action) â–¼â–¼â–¼
    // ==========================================
    let isPlaying = false;
    let score = 0;
    let seedsCollected = 0;
    let gravity = 0.6;
    let speed = 7;
    let nextFriendScoreTarget = 1000;
    let spawnFriendFlag = false;
    let playerHistory = []; 
    let hasFoundShopHamster = false; // ä»Šå›ã®å†’é™ºã§ã‚·ãƒ§ãƒƒãƒ—ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’è¦‹ã¤ã‘ãŸã‹

    function getMaxSeedCapacity() { return (1 + followers.length) * SEED_CAPACITY_PER_HAMSTER; }

    const player = {
        x: 150, y: 0, width: 68, height: 68, dy: 0, jumpPower: -13, color: '#ff3f34', isGrounded: false, jumpCount: 0, maxJumps: 2,
        draw: function() {
            let img = sprites.run.loaded ? sprites.run.img : null;
            if (!this.isGrounded) {
                if (this.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                else img = sprites.jump.loaded ? sprites.jump.img : img;
            }
            if(img) ctx.drawImage(img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
        },
        update: function() {
            this.dy += gravity; this.y += this.dy;
            if (this.y > canvas.height) gameOver();
        },
        jump: function() {
            if (this.isGrounded || this.jumpCount < this.maxJumps) {
                this.dy = this.jumpPower; this.jumpCount++; this.isGrounded = false;
                if (this.jumpCount === 2) this.dy = this.jumpPower * 0.9;
            } else if (followers.length > 0) {
                this.dy = this.jumpPower; this.isGrounded = false;
                followers.shift(); detachedFriends.push(new DetachedFriend(this.x, this.y + this.height));
                let currentMax = getMaxSeedCapacity(); if (seedsCollected > currentMax) seedsCollected = currentMax; updateSeedDisplay();
            }
        },
        land: function(y) { this.y = y - this.height; this.dy = 0; this.isGrounded = true; this.jumpCount = 0; }
    };

    class DetachedFriend {
        constructor(x, y) { this.x = x; this.y = y; this.width = 68; this.height = 68; this.dy = 5; this.isDead = false; }
        update() { this.dy += gravity; this.y += this.dy; this.x -= speed; }
        draw() {
            if (sprites.fall.loaded) {
                ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); ctx.rotate(Math.random()); 
                ctx.drawImage(sprites.fall.img, -this.width/2, -this.height/2, this.width, this.height); ctx.restore();
            } else { ctx.fillStyle = '#ff6b6b'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
    }
    let detachedFriends = [];
    class Seed {
        constructor(x, y) { this.x = x; this.y = y; this.width = 15; this.height = 20; this.collected = false; }
        draw() {
            if (this.collected) return;
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(this.x + this.width/2, this.y + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2); ctx.fill(); }
        }
        update() { this.x -= speed; }
    }
    let seeds = [];
    
    class Collectible {
        constructor(x, y, isShopHamster = false) { 
            this.x = x; this.y = y; this.width = 68; this.height = 68; 
            this.isShopHamster = isShopHamster;
        }
        draw() {
            ctx.globalAlpha = 1.0;
            if (this.isShopHamster) {
                // ã‚·ãƒ§ãƒƒãƒ—ãƒãƒ ã‚¹ã‚¿ãƒ¼ã¯é’è‰²ã£ã½ã„ã‚ªãƒ¼ãƒ©
                ctx.save();
                ctx.fillStyle = '#0984e3'; ctx.globalAlpha = 0.5;
                ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
            if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = this.isShopHamster ? '#0984e3' : '#feca57'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
        update() { this.x -= speed; }
    }
    let collectibles = []; let followers = []; let platforms = [];
    
    class SlopePlatform {
        constructor(x, y, width, slopeType) {
            this.x = x; this.y = y; this.width = width; this.slopeType = slopeType;
            const heightDiff = width * 0.5;
            if (slopeType === 1) { this.endY = this.y - heightDiff; this.slopeFactor = -heightDiff / width; }
            else if (slopeType === -1) { this.endY = this.y + heightDiff; this.slopeFactor = heightDiff / width; }
            else { this.endY = this.y; this.slopeFactor = 0; }
            this.pillars = []; let currentX = 0;
            while (currentX < this.width) {
                let w = 10 + Math.random() * 0;
                let g = 0;
                if (currentX + w > this.width) w = this.width - currentX;
                let pillarTopY = this.y + (currentX * this.slopeFactor);
                this.pillars.push({ relX: currentX, endRelX: currentX + w, y: pillarTopY, w: w }); currentX += w + g;
            }
        }
        getPillarHeightAt(targetX) {
            let relX = targetX - this.x; if (relX < 0 || relX > this.width) return null;
            for (let p of this.pillars) { if (relX >= p.relX && relX <= p.endRelX) return p.y; } return null;
        }
        draw() {
            ctx.fillStyle = '#0be881';
            for (let p of this.pillars) {
                let drawX = this.x + p.relX; if (drawX > canvas.width || drawX + p.w < 0) continue;
                ctx.fillRect(drawX, p.y, p.w, canvas.height - p.y);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.endY); ctx.stroke();
        }
        update() { this.x -= speed; }
    }
    
    function addPlatform(x) {
        const width = 300 + Math.random() * 300;
        let lastEndY = platforms.length > 0 ? platforms[platforms.length - 1].endY : canvas.height / 2;
        let startY = lastEndY + (Math.random() * 200 - 100); 
        if (startY < 150) startY = 150; if (startY > canvas.height - 150) startY = canvas.height - 150;
        const r = Math.random(); let type = 0;
        if (r < 0.4) type = 1; else if (r < 0.7) type = -1; else type = 0;
        if (startY < 200) type = -1; if (startY > canvas.height - 200) type = 1;
        
        const newPlatform = new SlopePlatform(x, startY, width, type); platforms.push(newPlatform);
        
        // Seeds
        let currentSeedX = 30;
        while (currentSeedX < width - 30) {
            if (Math.random() < 0.7) {
                let isAir = Math.random() < 0.3;
                let groundY = newPlatform.y + (currentSeedX * newPlatform.slopeFactor);
                let seedY = isAir ? groundY - 100 - (Math.random() * 50) : groundY - 25; 
                let seedX = newPlatform.x + currentSeedX; seeds.push(new Seed(seedX, seedY));
            }
            currentSeedX += 60;
        }
        
        // Items (Friends or Shop Hamster)
        // 1000mä»˜è¿‘ã‹ã¤æœªé–‹æ”¾ãªã‚‰ã‚·ãƒ§ãƒƒãƒ—ãƒãƒ ã‚¹ã‚¿ãƒ¼å‡ºç¾
        let currentDist = score / 10;
        let isShopSpawn = (!shopUnlocked && !hasFoundShopHamster && currentDist > 950 && currentDist < 1050 && Math.random() < 0.5);
        
        if (spawnFriendFlag || isShopSpawn) {
            let centerX = width / 2; let centerY = newPlatform.y + (centerX * newPlatform.slopeFactor);
            let itemY = centerY - 45; 
            let itemX = x + centerX;
            collectibles.push(new Collectible(itemX, itemY, isShopSpawn)); 
            if(!isShopSpawn) spawnFriendFlag = false; // æ™®é€šã®ä»²é–“ãªã‚‰ãƒ•ãƒ©ã‚°å›å
        }
    }

    function gameLoop() {
        if (gameState !== 'playing') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        player.update();
        playerHistory.unshift({ footY: player.y + player.height, isGrounded: player.isGrounded, jumpCount: player.jumpCount }); 
        let maxHistory = (followers.length + 1) * 15; if (playerHistory.length > maxHistory + 100) playerHistory.length = maxHistory + 100;
        
        if (score >= nextFriendScoreTarget) { spawnFriendFlag = true; nextFriendScoreTarget += (FRIEND_INTERVAL_METER * 10); }
        
        if (platforms.length === 0 || platforms[platforms.length - 1].x < canvas.width - 50) {
            if (platforms.length === 0) addPlatform(0);
            else {
                let gap = 50 + Math.random() * 100;
                addPlatform(platforms[platforms.length - 1].x + platforms[platforms.length - 1].width + gap);
            }
        }
        player.isGrounded = false;
        
        // Platform Collision
        for (let i = 0; i < platforms.length; i++) {
            let plat = platforms[i]; plat.update(); plat.draw();
            if (player.x + player.width > plat.x && player.x < plat.x + plat.width) {
                let footX = player.x + player.width / 2; let pillarY = plat.getPillarHeightAt(footX);
                if (pillarY !== null) { if (player.y + player.height >= pillarY - 10 && player.y + player.height <= pillarY + 30 && player.dy >= 0) player.land(pillarY); }
            }
            // Friends falling collision
            for (let j = 0; j < detachedFriends.length; j++) {
                let df = detachedFriends[j];
                if (!df.isDead && df.x + df.width > plat.x && df.x < plat.x + plat.width) {
                    let dfFootX = df.x + df.width / 2; let dfPillarY = plat.getPillarHeightAt(dfFootX);
                    if (dfPillarY !== null && df.y + df.height >= dfPillarY - 10 && df.dy >= 0) { 
                        followers.push({}); df.isDead = true; updateSeedDisplay(); 
                    }
                }
            }
            if (plat.x + plat.width < 0) { platforms.splice(i, 1); i--; }
        }
        
        // Detached Friends
        for (let i = 0; i < detachedFriends.length; i++) {
            let df = detachedFriends[i]; df.update(); df.draw();
            if (df.y > canvas.height || df.x + df.width < 0 || df.isDead) { detachedFriends.splice(i, 1); i--; }
        }
        
        // Seeds
        for (let i = 0; i < seeds.length; i++) {
            let seed = seeds[i]; seed.update(); seed.draw();
            if (!seed.collected && player.x < seed.x + seed.width && player.x + player.width > seed.x && player.y < seed.y + seed.height && player.y + player.height > seed.y) {
                let currentMax = getMaxSeedCapacity();
                if (seedsCollected < currentMax) { seed.collected = true; seedsCollected++; updateSeedDisplay(); }
            }
            if (seed.x + seed.width < 0 || (seed.collected && seed.x < player.x - 200)) { seeds.splice(i, 1); i--; }
        }
        
        // Collectibles
        for (let i = 0; i < collectibles.length; i++) {
            let item = collectibles[i]; item.update(); item.draw();
            if (player.x < item.x + item.width && player.x + player.width > item.x && player.y < item.y + item.height && player.y + player.height > item.y) {
                followers.push({}); 
                if(item.isShopHamster) hasFoundShopHamster = true;
                collectibles.splice(i, 1); i--; updateSeedDisplay();
            } else if (item.x + item.width < 0) { collectibles.splice(i, 1); i--; }
        }
        
        // Followers
        for (let i = 0; i < followers.length; i++) {
            let delayFrame = 7 * (i + 1); let size = 68;
            let pastState = playerHistory[delayFrame] || playerHistory[playerHistory.length-1];
            if (pastState) {
                let followX = player.x - (delayFrame * speed); let drawY = pastState.footY - size;
                if (followX > -100) {
                    let img = sprites.run.loaded ? sprites.run.img : null;
                    if (!pastState.isGrounded) {
                        if (pastState.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                        else img = sprites.jump.loaded ? sprites.jump.img : img;
                    }
                    if(img) ctx.drawImage(img, followX, drawY, size, size);
                    else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(followX, drawY, size, size); }
                }
            }
        }
        
        player.draw(); score++; document.getElementById('score').innerText = 'Distance: ' + Math.floor(score / 10) + 'm';
        requestAnimationFrame(gameLoop);
    }
    
    // ==========================================
    // â–¼â–¼â–¼ å…¥åŠ›ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° (Swipe, Tap) â–¼â–¼â–¼
    // ==========================================
    let touchStartX = 0; let touchStartY = 0;
    let draggedHamster = null; let dragOffsetX = 0; let dragOffsetY = 0;
    let lastDragX = 0; let lastDragY = 0; let dragVelocityX = 0; let dragVelocityY = 0;

    function handleInputStart(e) {
        if (!gameStarted) return; 
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
        
        let cx, cy;
        if(e.type === 'touchstart') { 
            // e.preventDefault(); // ã“ã“ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã¨ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜»å®³ã®å¯èƒ½æ€§ã‚ã‚Šã€èª¿æ•´
            touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; 
        } else { 
            touchStartX = e.clientX; touchStartY = e.clientY; 
        }
        cx = touchStartX; cy = touchStartY;

        // Canvaså†…åº§æ¨™å¤‰æ›
        let rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width; let scaleY = canvas.height / rect.height;
        let gameX = (cx - rect.left) * scaleX; let gameY = (cy - rect.top) * scaleY;

        if (gameState === 'nest') {
            // ãƒãƒ ã‚¹ã‚¿ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®š
            for(let h of nestHamsters) {
                let dx = h.x - gameX; let dy = (h.y - h.size/2) - gameY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < h.size) {
                    draggedHamster = h; h.isDragging = true; h.isThrown = false; h.vx = 0; h.vy = 0;
                    dragOffsetX = h.x - gameX; dragOffsetY = (h.y - h.size/2) - gameY;
                    lastDragX = gameX; lastDragY = gameY;
                    return; 
                }
            }
            // ç¨®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒˆ
            for(let s of nestSeeds) {
                let dx = s.x - gameX; let dy = s.y - gameY; let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 100) {
                    let force = (100 - dist) * 0.2; s.wakeUp();
                    s.vx += (dx/dist) * force + (Math.random()-0.5)*5; s.vy -= force * 0.5 + Math.random()*5;
                }
            }
        } else if (gameState === 'playing') {
            player.jump();
        }
    }

    function handleInputMove(e) {
        if (gameState === 'nest' && draggedHamster) {
            e.preventDefault();
            let cx, cy;
            if(e.type === 'touchmove') { cx = e.touches[0].clientX; cy = e.touches[0].clientY; } 
            else { cx = e.clientX; cy = e.clientY; }
            let rect = canvas.getBoundingClientRect();
            let gameX = (cx - rect.left) * (canvas.width / rect.width);
            let gameY = (cy - rect.top) * (canvas.height / rect.height);
            draggedHamster.x = gameX + dragOffsetX; draggedHamster.y = gameY + dragOffsetY + draggedHamster.size/2;
            dragVelocityX = (gameX - lastDragX) * 0.5; dragVelocityY = (gameY - lastDragY) * 0.5;
            lastDragX = gameX; lastDragY = gameY;
        }
    }

    function handleInputEnd(e) {
        let touchEndX, touchEndY;
        if(e.type === 'touchend') { touchEndX = e.changedTouches[0].clientX; touchEndY = e.changedTouches[0].clientY; }
        else { touchEndX = e.clientX; touchEndY = e.clientY; }
        
        let diffX = touchEndX - touchStartX; 
        let diffY = touchEndY - touchStartY;

        // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†å‡¦ç†
        if (gameState === 'nest' && draggedHamster) {
            draggedHamster.isDragging = false; draggedHamster.isThrown = true;
            draggedHamster.vx = Math.max(-20, Math.min(20, dragVelocityX));
            draggedHamster.vy = Math.max(-20, Math.min(20, dragVelocityY));
            draggedHamster = null;
            return;
        }

        // ã‚¹ãƒ¯ã‚¤ãƒ—åˆ¤å®š (æ¨ªæ–¹å‘)
        if (Math.abs(diffX) > 50 && Math.abs(diffX) > Math.abs(diffY)) {
            if (gameState === 'nest' && diffX > 0) { // å³ã‚¹ãƒ¯ã‚¤ãƒ— -> ç•‘ã¸
                openField();
            } else if (gameState === 'field' && diffX < 0) { // å·¦ã‚¹ãƒ¯ã‚¤ãƒ— -> å·£ã¸
                closeField();
            } else if (gameState === 'playing' && diffX < -50) { // å·¦ã‚¹ãƒ¯ã‚¤ãƒ— -> ãƒãƒ¼ã‚º
                pauseGame();
            }
        }
    }

    window.addEventListener('mousedown', handleInputStart); window.addEventListener('mousemove', handleInputMove); window.addEventListener('mouseup', handleInputEnd);
    window.addEventListener('touchstart', handleInputStart, {passive: false}); window.addEventListener('touchmove', handleInputMove, {passive: false}); window.addEventListener('touchend', handleInputEnd);

    function updateSeedDisplay() {
        let currentMax = getMaxSeedCapacity();
        document.getElementById('seedCount').innerText = `Seeds: ${seedsCollected} / ${currentMax}`;
    }

    function pauseGame() { if (gameState !== 'playing') return; gameState = 'paused'; document.getElementById('pauseModal').style.display = 'block'; }
    
    function confirmGoHome() { 
        gameState = 'nest'; 
        let log = processTimePassage(seedsCollected, followers.length, hasFoundShopHamster);
        document.getElementById('logContent').innerHTML = log.join('<br>');
        document.getElementById('logModal').style.display = 'block';
        document.getElementById('pauseModal').style.display = 'none'; 
        initNest(); 
    }
    function closeLog() { document.getElementById('logModal').style.display = 'none'; }
    function cancelGoHome() { gameState = 'playing'; document.getElementById('pauseModal').style.display = 'none'; gameLoop(); }
    
    function gameOver() {
        gameState = 'gameover'; saveData();
        const modal = document.getElementById('gameOverModal');
        const text = document.getElementById('overlayText');
        text.innerHTML = `<h2>Game Over</h2><p>Distance: ${Math.floor(score / 10)}m</p><p>ç¨®ãƒ­ã‚¹ãƒˆ: ${seedsCollected}</p><p style="font-size:14px; color:#aaa;">ä»²é–“ã¨ã¯ãã‚Œã¦ã—ã¾ã£ãŸ...</p>`;
        modal.style.display = 'block';
    }
    function resetGame(initialFollowersCount = 0) {
        gameState = 'playing';
        document.getElementById('gameOverModal').style.display = 'none'; document.getElementById('pauseModal').style.display = 'none'; document.getElementById('instruction').style.display = 'none';
        platforms = []; seeds = []; collectibles = []; followers = []; detachedFriends = []; playerHistory = [];
        player.x = 150; player.y = canvas.height / 2; player.width = 68; player.height = 68; player.dy = 0; player.jumpCount = 0; player.color = '#ff3f34';
        
        hasFoundShopHamster = false; // ãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ

        for(let i=0; i<initialFollowersCount; i++){ 
            followers.push({}); 
            for(let j=0; j<15; j++) playerHistory.push({footY: player.y + player.height, isGrounded:true, jumpCount:0}); 
        }
        spawnFriendFlag = false; nextFriendScoreTarget = 1000; seedsCollected = 0; 
        updateSeedDisplay();
        platforms.push(new SlopePlatform(0, canvas.height / 2 + 100, canvas.width, 0));
        score = 0; document.getElementById('score').innerText = 'Distance: 0m';
        gameLoop();
    }
</script>
</body>
</html>
