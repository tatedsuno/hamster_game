<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hamster Adventure Final Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e272e;
            font-family: sans-serif;
            touch-action: none; /* ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ãƒƒãƒæ“ä½œã‚’ç„¡åŠ¹åŒ– */
            user-select: none;
            -webkit-user-select: none;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-layer {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            width: 100%;
            height: 100%;
            top: 0; left: 0;
        }
        .ui-text {
            position: absolute;
            right: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            text-align: right;
        }
        #score { top: 20px; font-size: 24px; color: #00d8d6; }
        #seedCount { top: 50px; font-size: 24px; color: #feca57; }
        #flickHint {
            top: 85px; 
            font-size: 16px; 
            color: #fff; 
            opacity: 0.8;
            background-color: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .btn {
            pointer-events: auto;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 0 #999;
            margin: 5px;
        }
        .btn:active {
            box-shadow: 0 2px 0 #999;
            transform: translateY(2px);
        }
        .btn:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            color: #fff;
            z-index: 80;
            display: none;
            width: 80%;
            max-width: 320px;
            border: 2px solid #fff;
        }

        #nestUI {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 500px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            z-index: 50;
            display: none;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
        }
        #nestStats {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2d3436;
            line-height: 1.6;
            text-align: left;
            padding: 0 10px;
        }
        .breed-info {
            font-size: 14px;
            color: #d63031;
            font-weight: bold;
        }
        .slider-container { margin: 10px 0; text-align: left; padding: 0 10px; }
        input[type=range] { width: 100%; }
        
        .action-area {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .action-area button {
            flex: 1;
        }

        #instruction {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            text-align: center;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
        }
        
        #logModal { z-index: 90; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1e272e; color: #fff; display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }

        #farmUI {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 500px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            z-index: 50;
            display: none;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
        }
        #farmStats {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2d3436;
            line-height: 1.6;
            text-align: left;
            padding: 0 10px;
        }
        #pageIndicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 60;
            display: none;
            gap: 10px;
            pointer-events: none;
        }
        .page-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.4);
            border: 2px solid rgba(0,0,0,0.2);
        }
        .page-dot.active {
            background-color: #fff;
            border-color: #555;
        }
    </style>
</head>
<body>

<div id="loading">Loading...</div>

<div class="ui-layer" id="gameUI">
    <div id="score" class="ui-text">Distance: 0m</div>
    <div id="seedCount" class="ui-text">Seeds: 0 / 100</div>
    <div id="flickHint" class="ui-text">â† ãƒ•ãƒªãƒƒã‚¯ã§å¸°å·£</div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="instruction" style="display:none;">ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</div>

<div id="pauseModal" class="modal">
    <h3>ğŸ  å¸°ã‚Šã¾ã™ã‹ï¼Ÿ</h3>
    <p>ä»Šã®ä»²é–“ã¨ç¨®ã‚’æŒã£ã¦<br>å·£ã«å¸°ã‚Šã¾ã™ã€‚</p>
    <button class="btn" style="background:#ff9f43; color:#fff;" onclick="confirmGoHome()">ã¯ã„ (å¸°ã‚‹)</button>
    <button class="btn" onclick="cancelGoHome()">ã„ã„ãˆ (æˆ»ã‚‹)</button>
</div>

<div id="breedingModal" class="modal">
    <h3>ğŸ’– å®¶æ—ã‚’å¢—ã‚„ã—ã¾ã™ã‹ï¼Ÿ</h3>
    <p style="text-align:left; display:inline-block;">
        <span style="color:#feca57">ğŸŒ» æ¶ˆè²»: ç¨® 600å€‹</span><br>
        <span style="color:#ff9f43">ğŸ¹ è¦ª: 1åŒ¹</span><br>
        <span style="font-size:12px; color:#aaa;">â€»è¦ªã¯è‚²å…ã®ãŸã‚å†’é™ºã«å‡ºã‚‰ã‚Œãªããªã‚Šã¾ã™</span>
    </p>
    <br><br>
    <button class="btn" style="background:#fd79a8; color:#fff;" onclick="confirmBreeding()">ã¯ã„ (ç¹æ®–ã™ã‚‹)</button>
    <button class="btn" onclick="cancelBreeding()">ã„ã„ãˆ (ã‚„ã‚ã‚‹)</button>
</div>

<div id="gameOverModal" class="modal">
    <div id="overlayText"></div>
    <br>
    <button class="btn" onclick="resetGame(selectedFriendsCount)">ãƒªãƒˆãƒ©ã‚¤</button>
    <br><br>
    <button class="btn" onclick="initNest()">å·£ã«æˆ»ã‚‹</button>
</div>

<div id="logModal" class="modal">
    <h3>ğŸ“ å†’é™ºæ—¥èªŒ</h3>
    <div id="logContent" style="text-align: left; margin: 10px 0; font-size: 14px;"></div>
    <button class="btn" onclick="closeLog()">é–‰ã˜ã‚‹</button>
</div>

<div id="nestUI">
    <div id="nestStats">
        <div>ğŸŒ» è²¯è”µç¨®: <b id="bankSeeds" style="color:#e67e22; font-size:20px;">0</b> å€‹</div>
        <div>ğŸ¹ å¤§äºº: <b id="bankFriends">0</b> åŒ¹ / ğŸ‘¶ å­ãƒãƒ : <b id="babyCount">0</b> åŒ¹</div>
        <div id="pregnantInfo" class="breed-info"></div>
    </div>
    <hr>
    <div class="slider-container">
        <label>é€£ã‚Œã¦è¡Œã: <b id="takeCount">0</b> åŒ¹</label>
        <input type="range" id="friendSlider" min="0" max="0" value="0" oninput="updateSlider()">
    </div>
    <div class="action-area">
        <button id="breedBtn" class="btn" style="background:#fd79a8; color:#fff;" onclick="startBreedingCheck()">ğŸ’– ç¹æ®–</button>
        <button class="btn" style="background:#00cec9; color:#fff;" onclick="departFromNest()">å†’é™ºã¸ï¼</button>
    </div>
</div>

<div id="farmUI">
    <div id="farmStats">
        <div>ğŸŒ» è²¯è”µç¨®: <b id="farmBankSeeds" style="color:#e67e22; font-size:20px;">0</b> å€‹</div>
        <div>ğŸ¹ ç•‘ãƒ¯ãƒ¼ã‚«ãƒ¼: <b id="farmWorkerCount">0</b> åŒ¹</div>
    </div>
    <hr>
    <div class="slider-container">
        <label>ãƒ¯ãƒ¼ã‚«ãƒ¼å‰²ã‚Šå½“ã¦: <b id="workerTakeCount">0</b> åŒ¹</label>
        <input type="range" id="workerSlider" min="0" max="0" value="0" oninput="updateWorkerSlider()">
    </div>
    <div class="action-area">
        <button class="btn" style="background:#f39c12; color:#fff;" onclick="harvestAll()">ğŸŒ» ä¸€æ‹¬åç©«</button>
        <button id="expandBtn" class="btn" style="background:#27ae60; color:#fff;" onclick="expandFarm()">ğŸ”¨ æ‹¡å¼µ</button>
    </div>
</div>

<div id="pageIndicator">
    <div class="page-dot active" id="dotNest"></div>
    <div class="page-dot" id="dotFarm"></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // â–¼â–¼â–¼ ç”»åƒèª­ã¿è¾¼ã¿ â–¼â–¼â–¼
    const sprites = {
        idle: { img: new Image(), loaded: false },
        run: { img: new Image(), loaded: false },
        jump: { img: new Image(), loaded: false },
        djump: { img: new Image(), loaded: false },
        fall: { img: new Image(), loaded: false },
        seed: { img: new Image(), loaded: false }
    };
    
    sprites.idle.img.src = 'ham.idle.png';
    sprites.run.img.src = 'ham.run.png';
    sprites.jump.img.src = 'ham.jump.png';
    sprites.djump.img.src = 'ham.djump.png';
    sprites.fall.img.src = 'ham.fall.png';
    sprites.seed.img.src = 'seed.png';

    let imagesLoadedCount = 0;
    const totalImages = Object.keys(sprites).length;
    let gameStarted = false;

    function checkAllImagesLoaded() {
        imagesLoadedCount++;
        if (imagesLoadedCount >= totalImages) {
            startGame();
        }
    }

    function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        document.getElementById('loading').style.display = 'none';
        
        // åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã¯å·£ã‚’è¡¨ç¤º
        if (localStorage.getItem('ham_seeds')) initNest(); else initNest();
    }

    for (let key in sprites) {
        sprites[key].img.onload = function() {
            sprites[key].loaded = true;
            checkAllImagesLoaded();
        };
        sprites[key].img.onerror = function() {
            console.warn("Image load failed: " + sprites[key].img.src);
            sprites[key].loaded = false; 
            checkAllImagesLoaded(); 
        };
    }

    // 3ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç”»åƒã‚¨ãƒ©ãƒ¼æ™‚ã‚‚å¼·åˆ¶é–‹å§‹ï¼‰
    setTimeout(() => {
        if (!gameStarted) {
            console.warn("Loading timeout. Force start.");
            startGame();
        }
    }, 3000);


    // ==========================================
    // â–¼â–¼â–¼ è¨­å®šã‚¨ãƒªã‚¢ â–¼â–¼â–¼
    // ==========================================
    const ZOOM_SCALE = 0.6; 
    const FRIEND_INTERVAL_METER = 200; 
    const NEST_FLOOR_OFFSET = 650; 
    const MAX_PHYSICS_SEEDS = 200;
    const SEED_CAPACITY_PER_HAMSTER = 100;
    const BREEDING_COST_SEEDS = 600;
    const BABIES_PER_BIRTH = 6;

    const BREEDING_CONFIG = {
        pregnancyTime: 120000,
        babyGrowthTime: 180000
    };

    const FARM_CONFIG = {
        initialRows: 3,
        initialCols: 4,
        plantCost: 5,
        harvestYieldMin: 20,
        harvestYieldMax: 30,
        growthTime: 15000,
        waterBoost: 0.5,
        workerCostPerTrip: 2,
        expansionCost: 200,
        maxRows: 6,
        workerActionInterval: 3000
    };
    const GROWTH_STAGES = ['empty', 'seeded', 'sprout', 'growing', 'blooming', 'harvestable'];

    const PILLAR_CONFIG = { minWidth: 10, maxWidth: 10, minGap: 0, maxGap: 0, baseColor: '#0be881' };
    const SPAWN_PATTERNS = {
        normal: { name: "åŸºæœ¬ãƒ¢ãƒ¼ãƒ‰", weight: 60, width: { min: 300, max: 600 }, gap: { min: 50, max: 150 } },
        rapid: { name: "é€£æ‰“ãƒ¢ãƒ¼ãƒ‰", weight: 30, width: { min: 30, max: 150 }, gap: { min: 30, max: 80 } },
        longJump: { name: "å¤§ã‚¸ãƒ£ãƒ³ãƒ—ãƒ¢ãƒ¼ãƒ‰", weight: 10, width: { min: 200, max: 400 }, gap: { min: 180, max: 500 } }
    };

    function resize() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        canvas.width = screenWidth / ZOOM_SCALE;
        canvas.height = screenHeight / ZOOM_SCALE;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // â–¼â–¼â–¼ çŠ¶æ…‹ãƒ»ãƒ‡ãƒ¼ã‚¿ç®¡ç† â–¼â–¼â–¼
    // ==========================================
    let gameState = 'loading';
    let bankSeeds = parseInt(localStorage.getItem('ham_seeds') || '0');
    let bankFriends = parseInt(localStorage.getItem('ham_friends') || '0');
    let breedingQueue = JSON.parse(localStorage.getItem('ham_breeding') || '[]');
    breedingQueue.forEach(q => {
        if (q.tripsRemaining !== undefined && q.startedAt === undefined) {
            q.startedAt = Date.now();
            delete q.tripsRemaining;
        }
    });
    let selectedFriendsCount = 0; 

    let farmWorkers = parseInt(localStorage.getItem('ham_farm_workers') || '0');
    let farmRows = parseInt(localStorage.getItem('ham_farm_rows') || String(FARM_CONFIG.initialRows));
    let farmPlots = JSON.parse(localStorage.getItem('ham_farm_plots') || 'null');
    if (!farmPlots) {
        farmPlots = [];
        for (let i = 0; i < FARM_CONFIG.initialRows * FARM_CONFIG.initialCols; i++) {
            farmPlots.push({ state: 'empty', stageStartedAt: 0, watered: false });
        }
    }
    
    // ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œç”¨
    let draggedHamster = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function saveData() {
        localStorage.setItem('ham_seeds', bankSeeds);
        localStorage.setItem('ham_friends', bankFriends);
        localStorage.setItem('ham_breeding', JSON.stringify(breedingQueue));
        localStorage.setItem('ham_farm_plots', JSON.stringify(farmPlots));
        localStorage.setItem('ham_farm_workers', farmWorkers);
        localStorage.setItem('ham_farm_rows', farmRows);
    }

    // ==========================================
    // â–¼â–¼â–¼ ç¹æ®–ãƒ»æ¶ˆè²»ã‚·ã‚¹ãƒ†ãƒ  â–¼â–¼â–¼
    // ==========================================
    function startBreedingCheck() {
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) {
            document.getElementById('breedingModal').style.display = 'block';
        }
    }

    function confirmBreeding() {
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) {
            bankSeeds -= BREEDING_COST_SEEDS;
            bankFriends -= 1; 
            breedingQueue.push({ type: 'pregnant', startedAt: Date.now(), count: 1 });
            saveData(); updateNestUI();
            nestSeeds.splice(0, Math.min(nestSeeds.length, 50)); 
        }
        closeBreedingModal();
    }

    function cancelBreeding() { closeBreedingModal(); }
    function closeBreedingModal() { document.getElementById('breedingModal').style.display = 'none'; }

    function updateBreeding() {
        let now = Date.now();
        let anyChanged = false;
        let newBabiesTotal = 0;
        let newAdultsTotal = 0;
        for (let i = 0; i < breedingQueue.length; i++) {
            let q = breedingQueue[i];
            if (q.type === 'pregnant') {
                if (now - q.startedAt >= BREEDING_CONFIG.pregnancyTime) {
                    bankFriends += q.count;
                    let babies = q.count * BABIES_PER_BIRTH;
                    newBabiesTotal += babies;
                    q.type = 'baby';
                    q.count = babies;
                    q.startedAt = now;
                    anyChanged = true;
                }
            } else if (q.type === 'baby') {
                if (now - q.startedAt >= BREEDING_CONFIG.babyGrowthTime) {
                    newAdultsTotal += q.count;
                    bankFriends += q.count;
                    q.done = true;
                    anyChanged = true;
                }
            }
        }
        if (anyChanged) {
            breedingQueue = breedingQueue.filter(q => !q.done);
            saveData();
        }
        return { newBabiesTotal, newAdultsTotal };
    }

    function processTimePassage(collectedSeeds, returnedFriendsCount) {
        let log = [];
        bankSeeds += collectedSeeds;
        log.push(`ç¨®ã‚’ ${collectedSeeds} å€‹æŒã¡å¸°ã‚Šã¾ã—ãŸã€‚`);
        
        if (returnedFriendsCount > 0) {
            bankFriends += returnedFriendsCount;
            log.push(`ä»²é–“ ${returnedFriendsCount} åŒ¹ãŒç„¡äº‹ã«å¸°é‚„ã—ã¾ã—ãŸï¼`);
        }

        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        let totalMouths = bankFriends + farmWorkers + pregnantCount + babyCount;
        let workerExtraCost = farmWorkers * FARM_CONFIG.workerCostPerTrip;
        let consumption = totalMouths * 1 + workerExtraCost; 
        log.push(`å…¨ ${totalMouths} åŒ¹ãŒç¨®ã‚’ ${consumption} å€‹é£Ÿã¹ã¾ã—ãŸã€‚`);
        if (farmWorkers > 0) log.push(`(\u7551\u30EF\u30FC\u30AB\u30FC ${farmWorkers} \u5339\u306E\u8FFD\u52A0\u30B3\u30B9\u30C8: ${workerExtraCost})`);

        if (bankSeeds >= consumption) { bankSeeds -= consumption; } else {
            let survivors = bankSeeds; let casualties = totalMouths - survivors;
            bankSeeds = 0; 
            log.push(`<span style="color:red">ç¨®ãŒè¶³ã‚Šãªã„ï¼ ${casualties} åŒ¹ãŒé¤“æ­»ã—ã¾ã—ãŸ...</span>`);
            for (let i = breedingQueue.length - 1; i >= 0; i--) {
                if (casualties <= 0) break; let group = breedingQueue[i];
                if (group.count <= casualties) { casualties -= group.count; breedingQueue.splice(i, 1); }
                else { group.count -= casualties; casualties = 0; }
            }
            if (casualties > 0) { bankFriends = Math.max(0, bankFriends - casualties); }
        }

        let breeding = updateBreeding();
        if (breeding.newBabiesTotal > 0) log.push(`\u{1F476} <span style="color:#fd79a8">\u8D64\u3061\u3083\u3093\u304C ${breeding.newBabiesTotal} \u5339\u751F\u307E\u308C\u307E\u3057\u305F\uFF01</span>`);
        if (breeding.newAdultsTotal > 0) log.push(`\u{1F439} <span style="color:#00cec9">\u5B50\u30CF\u30E0 ${breeding.newAdultsTotal} \u5339\u304C\u5927\u4EBA\u306B\u306A\u308A\u307E\u3057\u305F\uFF01</span>`);
        
        saveData(); return log;
    }

    // ==========================================
    // â–¼â–¼â–¼ å·£ã®æç”»ãƒ»UI â–¼â–¼â–¼
    // ==========================================
    let nestHamsters = []; let nestSeeds = []; 

    class PhysicsSeed {
        constructor(x, y) {
            this.x = x; this.y = y; this.physRadius = 5; this.drawRadius = 12; 
            this.vx = (Math.random() - 0.5) * 5; this.vy = Math.random() * 5;
            this.rotation = Math.random() * Math.PI * 2; this.sleeping = false; 
        }
        wakeUp() { this.sleeping = false; }
        update() {
            if (this.sleeping) return; 
            this.vy += 0.5; this.x += this.vx; this.y += this.vy;
            this.vx *= 0.95; this.vy *= 0.95;
            let floorY = canvas.height - NEST_FLOOR_OFFSET;
            if (this.y + this.physRadius > floorY) { this.y = floorY - this.physRadius; this.vy *= -0.3; this.vx *= 0.7; }
            if (this.x - this.physRadius < 0) { this.x = this.physRadius; this.vx *= -0.5; }
            if (this.x + this.physRadius > canvas.width) { this.x = canvas.width - this.physRadius; this.vx *= -0.5; }
            if (Math.abs(this.vx) < 0.05 && Math.abs(this.vy) < 0.1 && this.y > floorY - this.physRadius - 5) { this.vx = 0; this.vy = 0; this.sleeping = true; }
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation + this.x * 0.1); 
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, -10, -12, 20, 25);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(0, 0, 10, 12, 0, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        }
    }

    class NestHamster {
        constructor(stage = 0) { 
            this.stage = stage;
            this.x = Math.random() * canvas.width;
            
            // â˜…ä¿®æ­£: Yåº§æ¨™ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†æ•£ã•ã›ã¦è¦‹ä¸‹ã‚ã—æ„Ÿã‚’å‡ºã™
            let floorTop = canvas.height - NEST_FLOOR_OFFSET;
            let depthRange = 250; // å¥¥è¡Œãã®ç¯„å›²
            this.y = floorTop + Math.random() * depthRange; 
            this.groundY = this.y; // å€‹åˆ¥ã®åœ°é¢ã®é«˜ã•ã‚’è¨˜æ†¶

            if (this.stage === 2) { 
                this.size = 40; this.state = 'newborn'; 
            } else if (this.stage === 1) { 
                this.size = 65; this.state = 'idle'; 
            } else { 
                this.size = 90; this.state = 'idle'; 
            }

            this.timer = Math.random() * 60; 
            this.vx = 0; 
            this.vy = 0; 
            this.flip = false; 
            this.lastFlip = false;
            this.hopOffset = Math.random() * Math.PI;
            
            this.isDragging = false;
            this.isThrown = false; 
        }

        update() {
            if (this.isDragging) return;

            // â˜…ä¿®æ­£: ç‰©ç†æ¼”ç®—ã®ç€åœ°åˆ¤å®šã‚’å€‹åˆ¥ã® groundY åŸºæº–ã«ã™ã‚‹
            if (this.isThrown || this.y < this.groundY) {
                this.vy += 0.5; 
                this.x += this.vx;
                this.y += this.vy;

                if (this.y > this.groundY) {
                    this.y = this.groundY;
                    this.vy *= -0.5; 
                    this.vx *= 0.8;  
                    if (Math.abs(this.vy) < 1) {
                        this.isThrown = false;
                        this.vy = 0;
                    }
                }
                if (this.x < 0) { this.x = 0; this.vx *= -0.7; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.7; }
                
                if(Math.abs(this.vx) > 1) this.flip = this.vx < 0;

                this.interactWithSeeds();
                return;
            }

            if (this.stage === 2) return; 

            this.timer--;
            if (this.timer <= 0) {
                if (this.state === 'idle') {
                    this.state = 'move'; this.timer = 10 + Math.random() * 30; 
                    let baseSpeed = (this.stage === 1) ? 6 : 4; 
                    let speed = baseSpeed + Math.random() * 3;
                    this.vx = (Math.random() < 0.5) ? speed : -speed; 
                } else {
                    this.state = 'idle'; this.timer = 20 + Math.random() * 60; this.vx = 0;
                }
            }
            this.x += this.vx;
            if (this.x < 0) { this.x = 0; this.vx *= -1; }
            if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -1; }
            
            if (this.vx !== 0) {
                this.lastFlip = this.vx < 0; 
            }
            this.flip = this.lastFlip;

            if (this.state === 'move') {
                this.interactWithSeeds();
            }
        }

        interactWithSeeds() {
            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed < 1.0) return;

            for (let s of nestSeeds) {
                let dx = s.x - this.x; let dy = s.y - (this.y - this.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < this.size * 0.6) { 
                    s.wakeUp(); 
                    let angle = Math.atan2(dy, dx); 
                    let kickPower = speed * 0.3; 
                    if (kickPower > 10) kickPower = 10;
                    s.vx += Math.cos(angle) * kickPower; 
                    s.vy += Math.sin(angle) * kickPower - 0.5; 
                }
            }
        }

        draw() {
            let hopY = 0;
            if (!this.isThrown && !this.isDragging) {
                if (this.stage === 2) {
                    if (Math.random() < 0.02) hopY = -5; 
                } else {
                    hopY = (this.state === 'move') ? Math.sin(Date.now() / 20 + this.hopOffset) * 5 : 0; 
                }
            }
            
            ctx.save(); 
            ctx.translate(this.x, this.y - this.size/2 + hopY);
            if (this.isDragging) ctx.scale(1.1, 1.1);
            if (this.flip) ctx.scale(-1, 1);
            
            let img = sprites.idle.loaded ? sprites.idle.img : null;
            if (this.state === 'move' && !this.isDragging && !this.isThrown && sprites.run.loaded) img = sprites.run.img;
            if ((this.isThrown || this.isDragging) && sprites.fall.loaded) img = sprites.fall.img;
            if (this.stage === 2 && sprites.idle.loaded) img = sprites.idle.img;
            
            if (img) ctx.drawImage(img, -this.size/2, -this.size/2, this.size, this.size);
            else { ctx.fillStyle = this.stage === 2 ? '#fab1a0' : '#ff9f43'; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); }
            ctx.restore();
        }
    }

    function initNest() {
        gameState = 'nest';
        document.getElementById('nestUI').style.display = 'block';
        document.getElementById('farmUI').style.display = 'none';
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('gameOverModal').style.display = 'none';
        document.getElementById('pauseModal').style.display = 'none';
        document.getElementById('breedingModal').style.display = 'none';
        document.getElementById('instruction').style.display = 'none';
        updateFarmGrowth();
        updatePageIndicator('nest');
        updateNestUI();
        nestHamsters = [];
        
        let displayAdults = Math.min(bankFriends, 30);
        for(let i=0; i<displayAdults; i++) nestHamsters.push(new NestHamster(0)); 
        
        breedingQueue.forEach(q => {
            if(q.type === 'baby') {
                let progress = (Date.now() - q.startedAt) / BREEDING_CONFIG.babyGrowthTime;
                let stage = progress < 0.5 ? 2 : 1;
                let count = Math.min(q.count, 20);
                for(let i=0; i<count; i++) nestHamsters.push(new NestHamster(stage));
            }
        });

        nestSeeds = [];
        let physicsCount = Math.min(bankSeeds, MAX_PHYSICS_SEEDS);
        for (let i = 0; i < physicsCount; i++) {
            let dropX = (canvas.width / 2) + (Math.random() - 0.5) * 40;
            nestSeeds.push(new PhysicsSeed(dropX, -Math.random() * 500));
        }
        nestLoop();
    }

    function formatTimeRemaining(ms) {
        if (ms <= 0) return '\u307E\u3082\u306A\u304F';
        let sec = Math.ceil(ms / 1000);
        let m = Math.floor(sec / 60);
        let s = sec % 60;
        return m > 0 ? `${m}\u5206${s}\u79D2` : `${s}\u79D2`;
    }

    function updateNestUI() {
        document.getElementById('bankSeeds').innerText = bankSeeds;
        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        document.getElementById('bankFriends').innerText = bankFriends;
        document.getElementById('babyCount').innerText = babyCount;
        let infoText = "";
        let now = Date.now();
        breedingQueue.forEach(q => {
            if (q.type === 'pregnant') {
                let remaining = BREEDING_CONFIG.pregnancyTime - (now - q.startedAt);
                infoText += `\u{1F930} \u51FA\u7523\u307E\u3067: ${formatTimeRemaining(remaining)} (${q.count}\u5339)\n`;
            } else if (q.type === 'baby') {
                let remaining = BREEDING_CONFIG.babyGrowthTime - (now - q.startedAt);
                infoText += `\u{1F476} \u6210\u9577\u307E\u3067: ${formatTimeRemaining(remaining)} (${q.count}\u5339)\n`;
            }
        });
        document.getElementById('pregnantInfo').innerText = infoText;
        const breedBtn = document.getElementById('breedBtn');
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) { breedBtn.disabled = false; breedBtn.style.opacity = 1; } else { breedBtn.disabled = true; breedBtn.style.opacity = 0.5; }
        const slider = document.getElementById('friendSlider'); slider.max = bankFriends;
        if (parseInt(slider.value) > bankFriends) slider.value = bankFriends;
        updateSlider();
    }

    function nestLoop() {
        if (gameState !== 'nest') return;
        updateBreeding();
        updateNestUI();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffeaa7'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        let floorY = canvas.height - NEST_FLOOR_OFFSET;
        ctx.fillStyle = '#fdcb6e'; ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
        ctx.fillStyle = '#e1b12c'; ctx.fillRect(0, floorY, canvas.width, 10);
        let excessSeeds = bankSeeds - nestSeeds.length;
        if (excessSeeds > 0) drawStaticSeedPile(canvas.width / 2, floorY, excessSeeds);
        nestSeeds.forEach(s => s.update()); solvePhysics(); nestSeeds.forEach(s => s.draw());
        
        // â˜…ä¿®æ­£: æç”»é †åºã‚’Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆï¼ˆå¥¥ã‹ã‚‰æ‰‹å‰ã¸ï¼‰
        nestHamsters.sort((a, b) => a.y - b.y);
        nestHamsters.forEach(h => { h.update(); h.draw(); });
        
        // â˜…ä¿®æ­£: è‡ªæ©Ÿã‚’å·¨å¤§åŒ–ã—ã€æ‰‹å‰ã«é…ç½®
        let mySize = 200; // ã‚µã‚¤ã‚ºã‚’å¤§ãã(å…ƒ60)
        let myY = floorY + 100; // æ‰‹å‰(ä¸‹)ã«é…ç½®
        ctx.save(); ctx.translate(canvas.width/2 - mySize/2, myY - mySize/2);
        if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, 0, 0, mySize, mySize);
        else { ctx.fillStyle = '#ff3f34'; ctx.fillRect(0, 0, mySize, mySize); }
        ctx.restore();

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('\u2190 \u7551\u3078\u30B9\u30EF\u30A4\u30D7', 15, 20);

        requestAnimationFrame(nestLoop);
    }

    function drawStaticSeedPile(x, y, count) {
        let scale = Math.min(count / 1000, 3) + 0.5;
        let width = 200 * scale; let height = 80 * scale;
        ctx.fillStyle = '#d4ac0d'; ctx.beginPath(); ctx.ellipse(x, y + 20, width, height, 0, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#9a7d0a'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`+ ${count} Seeds`, x, y - height/2);
    }

    function solvePhysics() {
        const iter = 4; 
        for (let k = 0; k < iter; k++) {
            for (let i = 0; i < nestSeeds.length; i++) {
                let s1 = nestSeeds[i];
                for (let j = i + 1; j < nestSeeds.length; j++) {
                    let s2 = nestSeeds[j];
                    if (s1.sleeping && s2.sleeping) continue;
                    let dx = s2.x - s1.x; let dy = s2.y - s1.y; let distSq = dx*dx + dy*dy; let minDist = s1.physRadius + s2.physRadius; 
                    if (distSq < minDist * minDist && distSq > 0) {
                        let dist = Math.sqrt(distSq); let overlap = minDist - dist;
                        let forceX = (dx / dist) * overlap * 0.5; let forceY = (dy / dist) * overlap * 0.5;
                        s1.x -= forceX; s1.y -= forceY; s2.x += forceX; s2.y += forceY;
                        let avgVx = (s1.vx + s2.vx) * 0.5; let avgVy = (s1.vy + s2.vy) * 0.5;
                        s1.vx = s1.vx * 0.9 + avgVx * 0.1; s1.vy = s1.vy * 0.9 + avgVy * 0.1; s2.vx = s2.vx * 0.9 + avgVx * 0.1; s2.vy = s2.vy * 0.9 + avgVy * 0.1;
                    }
                }
            }
        }
    }

    function updateSlider() {
        const slider = document.getElementById('friendSlider');
        selectedFriendsCount = parseInt(slider.value);
        document.getElementById('takeCount').innerText = selectedFriendsCount;
    }

    function departFromNest() {
        bankFriends -= selectedFriendsCount; saveData();
        document.getElementById('nestUI').style.display = 'none'; document.getElementById('gameUI').style.display = 'block';
        document.getElementById('pageIndicator').style.display = 'none';
        resetGame(selectedFriendsCount);
    }

    // ==========================================
    // â–¼â–¼â–¼ ç•‘ã‚·ã‚¹ãƒ†ãƒ  â–¼â–¼â–¼
    // ==========================================
    let farmWorkerHamsters = [];
    let lastWorkerAction = 0;
    let farmFloatingTexts = [];

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 60; this.maxLife = 60;
        }
        update() { this.y -= 1.5; this.life--; }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1;
        }
    }

    class FarmWorkerHamster {
        constructor(startX, startY) {
            this.x = startX || canvas.width / 2 + (Math.random() - 0.5) * 200;
            this.y = startY || canvas.height / 2;
            this.groundY = this.y;
            this.size = 55;
            this.flip = false;
            this.hopOffset = Math.random() * Math.PI;
            this.speed = 3.5;
            this.vx = 0;
            this.vy = 0;

            this.state = 'wandering';
            this.targetX = 0;
            this.targetY = 0;
            this.targetPlotIdx = -1;
            this.targetAction = '';
            this.workTimer = 0;
            this.wanderVx = (Math.random() < 0.5 ? 1 : -1) * (1 + Math.random());
            this.idleTimer = 30 + Math.random() * 50;

            this.isDragging = false;
            this.isThrown = false;
        }

        assignTask(plotIdx, action, tx, ty) {
            if (this.isDragging || this.isThrown) return;
            this.targetPlotIdx = plotIdx;
            this.targetAction = action;
            this.targetX = tx;
            this.targetY = ty + this.size * 0.55;
            this.state = 'moving_to_target';
        }

        hasTask() {
            if (this.isDragging || this.isThrown) return true;
            return this.state === 'moving_to_target' || this.state === 'working';
        }

        update() {
            if (this.isDragging) return;

            if (this.isThrown) {
                this.vy += 0.5;
                this.x += this.vx;
                this.y += this.vy;
                if (this.y > this.groundY) {
                    this.y = this.groundY;
                    this.vy *= -0.5;
                    this.vx *= 0.8;
                    if (Math.abs(this.vy) < 1) {
                        this.isThrown = false;
                        this.vy = 0;
                        this.vx = 0;
                        this.state = 'idle';
                        this.idleTimer = 20 + Math.random() * 30;
                    }
                }
                if (this.x < 0) { this.x = 0; this.vx *= -0.7; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.7; }
                if (Math.abs(this.vx) > 1) this.flip = this.vx < 0;
                return;
            }

            if (this.state === 'working') {
                this.workTimer--;
                if (this.workTimer <= 0) {
                    this.state = 'idle';
                    this.idleTimer = 30 + Math.random() * 40;
                    this.targetPlotIdx = -1;
                }
                return;
            }

            if (this.state === 'moving_to_target') {
                let dx = this.targetX - this.x;
                let dy = this.targetY - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 5) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.doPlotAction();
                    this.state = 'working';
                    this.workTimer = 50;
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                    if (Math.abs(dx) > 1) this.flip = dx < 0;
                }
                return;
            }

            this.idleTimer--;
            if (this.idleTimer <= 0) {
                if (this.state === 'idle') {
                    this.state = 'wandering';
                    this.wanderVx = (Math.random() < 0.5 ? 1 : -1) * (1 + Math.random());
                    this.idleTimer = 25 + Math.random() * 35;
                } else {
                    this.state = 'idle';
                    this.wanderVx = 0;
                    this.idleTimer = 25 + Math.random() * 45;
                }
            }
            if (this.state === 'wandering') {
                this.x += this.wanderVx;
                if (this.x < 50) { this.x = 50; this.wanderVx *= -1; }
                if (this.x > canvas.width - 50) { this.x = canvas.width - 50; this.wanderVx *= -1; }
                if (this.wanderVx !== 0) this.flip = this.wanderVx < 0;
            }
        }

        doPlotAction() {
            if (this.targetPlotIdx < 0 || this.targetPlotIdx >= farmPlots.length) return;
            let plot = farmPlots[this.targetPlotIdx];
            let layout = getFarmGridLayout();
            let r = Math.floor(this.targetPlotIdx / layout.cols);
            let c = this.targetPlotIdx % layout.cols;
            let cx = layout.offsetX + c * (layout.cellSize + layout.gap) + layout.cellSize / 2;
            let cy = layout.offsetY + r * (layout.cellSize + layout.gap) + layout.cellSize / 2;

            if (this.targetAction === 'water' && !plot.watered && plot.state !== 'empty' && plot.state !== 'harvestable') {
                plot.watered = true;
                let now = Date.now();
                let elapsed = now - plot.stageStartedAt;
                let remaining = FARM_CONFIG.growthTime - elapsed;
                if (remaining > 0) plot.stageStartedAt -= Math.floor(remaining * FARM_CONFIG.waterBoost);
                farmFloatingTexts.push(new FloatingText(cx, cy, '\u{1F4A7}', '#3498db'));
            } else if (this.targetAction === 'plant' && plot.state === 'empty' && bankSeeds >= FARM_CONFIG.plantCost) {
                bankSeeds -= FARM_CONFIG.plantCost;
                plot.state = 'seeded';
                plot.stageStartedAt = Date.now();
                plot.watered = false;
                farmFloatingTexts.push(new FloatingText(cx, cy, '-' + FARM_CONFIG.plantCost, '#e74c3c'));
            }
            saveData();
            updateFarmUI();
        }

        draw() {
            let hopY = 0;
            if (!this.isDragging && !this.isThrown) {
                if (this.state === 'moving_to_target' || this.state === 'wandering') {
                    hopY = Math.sin(Date.now() / 80 + this.hopOffset) * 3;
                } else if (this.state === 'working') {
                    hopY = Math.sin(Date.now() / 40 + this.hopOffset) * 2;
                }
            }
            ctx.save();
            ctx.translate(this.x, this.y + hopY);
            if (this.isDragging) ctx.scale(1.1, 1.1);
            if (this.flip) ctx.scale(-1, 1);
            let isMoving = this.state === 'moving_to_target' || this.state === 'wandering';
            let img;
            if ((this.isThrown || this.isDragging) && sprites.fall.loaded) img = sprites.fall.img;
            else if (isMoving && sprites.run.loaded) img = sprites.run.img;
            else img = sprites.idle.loaded ? sprites.idle.img : null;
            if (img) ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);
            else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size); }
            ctx.restore();
        }
    }

    function getFarmGridLayout() {
        let cols = FARM_CONFIG.initialCols;
        let rows = farmRows;
        let maxGridWidth = Math.min(canvas.width * 0.85, 800);
        let gap = 15;
        let cellSize = Math.floor((maxGridWidth - (cols - 1) * gap) / cols);
        if (cellSize > 120) cellSize = 120;
        if (cellSize < 60) cellSize = 60;
        let gridWidth = cols * cellSize + (cols - 1) * gap;
        let gridHeight = rows * cellSize + (rows - 1) * gap;
        let offsetX = (canvas.width - gridWidth) / 2;
        let offsetY = 100;
        return { cols, rows, cellSize, gap, gridWidth, gridHeight, offsetX, offsetY };
    }

    function updateFarmGrowth() {
        let now = Date.now();
        let anyChanged = false;
        for (let plot of farmPlots) {
            if (plot.state === 'empty' || plot.state === 'harvestable') continue;
            let stageIndex = GROWTH_STAGES.indexOf(plot.state);
            if (stageIndex < 0) continue;
            let elapsed = now - plot.stageStartedAt;
            let stageTime = FARM_CONFIG.growthTime;
            let plotChanged = false;
            while (elapsed >= stageTime && stageIndex < GROWTH_STAGES.length - 1) {
                elapsed -= stageTime;
                stageIndex++;
                plot.watered = false;
                stageTime = FARM_CONFIG.growthTime;
                plotChanged = true;
            }
            if (plotChanged) {
                plot.state = GROWTH_STAGES[stageIndex];
                if (stageIndex < GROWTH_STAGES.length - 1) plot.stageStartedAt = now - elapsed;
                anyChanged = true;
            }
        }
        if (anyChanged) saveData();
    }

    function drawFarmPlot(cx, cy, cellSize, plot) {
        let s = cellSize;
        let half = s / 2;
        let pad = 4;
        ctx.fillStyle = '#8B6914';
        ctx.fillRect(cx - half + pad, cy - half + pad, s - pad * 2, s - pad * 2);
        ctx.fillStyle = '#725510';
        ctx.fillRect(cx - half + pad, cy - half + pad, s - pad * 2, 4);

        if (plot.state === 'empty') return;
        let baseY = cy + half - 15;

        if (plot.state === 'seeded') {
            ctx.fillStyle = '#4a3500';
            ctx.beginPath(); ctx.arc(cx - 6, baseY - 3, 3, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx + 6, baseY - 5, 3, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx, baseY - 8, 3, 0, Math.PI * 2); ctx.fill();
        } else if (plot.state === 'sprout') {
            ctx.strokeStyle = '#27ae60'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(cx, baseY); ctx.lineTo(cx, baseY - 22); ctx.stroke();
            ctx.fillStyle = '#2ecc71';
            ctx.save(); ctx.translate(cx - 8, baseY - 16); ctx.rotate(-0.5);
            ctx.beginPath(); ctx.ellipse(0, 0, 7, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            ctx.save(); ctx.translate(cx + 8, baseY - 18); ctx.rotate(0.5);
            ctx.beginPath(); ctx.ellipse(0, 0, 7, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        } else {
            let stemH = plot.state === 'growing' ? 35 : 50;
            ctx.strokeStyle = '#27ae60'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(cx, baseY); ctx.lineTo(cx, baseY - stemH); ctx.stroke();
            ctx.fillStyle = '#2ecc71';
            ctx.save(); ctx.translate(cx - 6, baseY - stemH * 0.4); ctx.rotate(-0.4);
            ctx.beginPath(); ctx.ellipse(0, 0, 13, 5, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            ctx.save(); ctx.translate(cx + 6, baseY - stemH * 0.6); ctx.rotate(0.4);
            ctx.beginPath(); ctx.ellipse(0, 0, 13, 5, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();

            if (plot.state !== 'growing') {
                let flowerY = baseY - stemH - 5;
                let fSize = plot.state === 'harvestable' ? 16 : 12;
                if (plot.state === 'harvestable') {
                    let pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse * 0.3;
                    ctx.fillStyle = '#f9e547';
                    ctx.beginPath(); ctx.arc(cx, flowerY, fSize + 10, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }
                ctx.fillStyle = '#f1c40f';
                for (let i = 0; i < 10; i++) {
                    let angle = (i / 10) * Math.PI * 2;
                    let px = cx + Math.cos(angle) * fSize;
                    let py = flowerY + Math.sin(angle) * fSize;
                    ctx.beginPath(); ctx.ellipse(px, py, 7, 4, angle, 0, Math.PI * 2); ctx.fill();
                }
                ctx.fillStyle = '#6F4E37';
                ctx.beginPath(); ctx.arc(cx, flowerY, fSize * 0.55, 0, Math.PI * 2); ctx.fill();
            }
        }

        if (plot.state !== 'empty' && plot.state !== 'harvestable') {
            let elapsed = Date.now() - plot.stageStartedAt;
            let progress = Math.min(elapsed / FARM_CONFIG.growthTime, 1);
            let barW = s - 24;
            let barH = 5;
            let barX = cx - barW / 2;
            let barY = cy + half - 8;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = plot.watered ? '#3498db' : '#2ecc71';
            ctx.fillRect(barX, barY, barW * progress, barH);
        }

        if (plot.watered && plot.state !== 'empty' && plot.state !== 'harvestable') {
            ctx.fillStyle = '#3498db';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('\u{1F4A7}', cx + half - 14, cy - half + 18);
        }
    }

    function initFarm() {
        gameState = 'farm';
        document.getElementById('farmUI').style.display = 'block';
        document.getElementById('nestUI').style.display = 'none';
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('gameOverModal').style.display = 'none';
        document.getElementById('pauseModal').style.display = 'none';
        document.getElementById('breedingModal').style.display = 'none';
        document.getElementById('instruction').style.display = 'none';
        updateFarmGrowth();
        updateFarmUI();
        updatePageIndicator('farm');
        farmWorkerHamsters = [];
        let displayW = Math.min(farmWorkers, 10);
        let fLayout = getFarmGridLayout();
        let fGroundY = fLayout.offsetY + fLayout.gridHeight + 50;
        for (let i = 0; i < displayW; i++) {
            let startX = fLayout.offsetX + Math.random() * fLayout.gridWidth;
            let w = new FarmWorkerHamster(startX, fGroundY);
            w.groundY = fGroundY;
            farmWorkerHamsters.push(w);
        }
        lastWorkerAction = Date.now();
        farmFloatingTexts = [];
        farmLoop();
    }

    function updateFarmUI() {
        document.getElementById('farmBankSeeds').innerText = bankSeeds;
        document.getElementById('farmWorkerCount').innerText = farmWorkers;
        let slider = document.getElementById('workerSlider');
        let totalAvailable = farmWorkers + bankFriends;
        slider.max = totalAvailable;
        slider.value = farmWorkers;
        document.getElementById('workerTakeCount').innerText = farmWorkers;
        let expandBtn = document.getElementById('expandBtn');
        if (farmRows >= FARM_CONFIG.maxRows) {
            expandBtn.disabled = true;
            expandBtn.innerText = '\u{1F528} \u6700\u5927';
        } else {
            expandBtn.disabled = bankSeeds < FARM_CONFIG.expansionCost;
            expandBtn.innerText = '\u{1F528} \u62E1\u5F35 (' + FARM_CONFIG.expansionCost + ')';
        }
    }

    function farmLoop() {
        if (gameState !== 'farm') return;
        updateFarmGrowth();
        updateBreeding();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#7ec850';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#6ab840';
        for (let i = 0; i < canvas.width; i += 50) {
            for (let j = 0; j < canvas.height; j += 50) {
                if ((Math.floor(i / 50) + Math.floor(j / 50)) % 2 === 0) ctx.fillRect(i, j, 50, 50);
            }
        }

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.shadowColor = '#333'; ctx.shadowBlur = 4;
        ctx.fillText('\u{1F33B} \u3072\u307E\u308F\u308A\u7551', canvas.width / 2, 50);
        ctx.shadowBlur = 0;

        let layout = getFarmGridLayout();
        for (let r = 0; r < layout.rows; r++) {
            for (let c = 0; c < layout.cols; c++) {
                let idx = r * layout.cols + c;
                if (idx >= farmPlots.length) continue;
                let cx = layout.offsetX + c * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                let cy = layout.offsetY + r * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                drawFarmPlot(cx, cy, layout.cellSize, farmPlots[idx]);
            }
        }

        farmWorkerHamsters.forEach(w => { w.update(); w.draw(); });

        let now = Date.now();
        if (farmWorkers > 0 && now - lastWorkerAction > FARM_CONFIG.workerActionInterval) {
            lastWorkerAction = now;
            performWorkerActions();
        }

        for (let i = farmFloatingTexts.length - 1; i >= 0; i--) {
            farmFloatingTexts[i].update();
            farmFloatingTexts[i].draw();
            if (farmFloatingTexts[i].life <= 0) farmFloatingTexts.splice(i, 1);
        }

        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'right'; ctx.textBaseline = 'top';
        ctx.fillText('\u2192 \u30B9\u30EF\u30A4\u30D7\u3067\u5DE3\u3078', canvas.width - 15, 55);

        requestAnimationFrame(farmLoop);
    }

    function handleFarmTap(cx, cy) {
        let layout = getFarmGridLayout();
        for (let r = 0; r < layout.rows; r++) {
            for (let c = 0; c < layout.cols; c++) {
                let idx = r * layout.cols + c;
                if (idx >= farmPlots.length) continue;
                let plot = farmPlots[idx];
                let px = layout.offsetX + c * (layout.cellSize + layout.gap);
                let py = layout.offsetY + r * (layout.cellSize + layout.gap);
                if (cx >= px && cx <= px + layout.cellSize && cy >= py && cy <= py + layout.cellSize) {
                    let centerX = px + layout.cellSize / 2;
                    let centerY = py + layout.cellSize / 2;
                    if (plot.state === 'empty') {
                        if (bankSeeds >= FARM_CONFIG.plantCost) {
                            bankSeeds -= FARM_CONFIG.plantCost;
                            plot.state = 'seeded';
                            plot.stageStartedAt = Date.now();
                            plot.watered = false;
                            farmFloatingTexts.push(new FloatingText(centerX, centerY, '-' + FARM_CONFIG.plantCost, '#e74c3c'));
                            saveData();
                        }
                    } else if (plot.state === 'harvestable') {
                        let yieldAmt = FARM_CONFIG.harvestYieldMin + Math.floor(Math.random() * (FARM_CONFIG.harvestYieldMax - FARM_CONFIG.harvestYieldMin + 1));
                        bankSeeds += yieldAmt;
                        plot.state = 'empty';
                        plot.stageStartedAt = 0;
                        plot.watered = false;
                        farmFloatingTexts.push(new FloatingText(centerX, centerY, '+' + yieldAmt, '#27ae60'));
                        saveData();
                    } else if (!plot.watered) {
                        plot.watered = true;
                        let elapsed = Date.now() - plot.stageStartedAt;
                        let remaining = FARM_CONFIG.growthTime - elapsed;
                        if (remaining > 0) {
                            plot.stageStartedAt -= Math.floor(remaining * FARM_CONFIG.waterBoost);
                        }
                        farmFloatingTexts.push(new FloatingText(centerX, centerY, '\u{1F4A7}', '#3498db'));
                        saveData();
                    }
                    updateFarmUI();
                    return;
                }
            }
        }
    }

    function harvestAll() {
        let total = 0;
        let layout = getFarmGridLayout();
        for (let r = 0; r < layout.rows; r++) {
            for (let c = 0; c < layout.cols; c++) {
                let idx = r * layout.cols + c;
                if (idx >= farmPlots.length) continue;
                let plot = farmPlots[idx];
                if (plot.state === 'harvestable') {
                    let yieldAmt = FARM_CONFIG.harvestYieldMin + Math.floor(Math.random() * (FARM_CONFIG.harvestYieldMax - FARM_CONFIG.harvestYieldMin + 1));
                    total += yieldAmt;
                    plot.state = 'empty';
                    plot.stageStartedAt = 0;
                    plot.watered = false;
                    let centerX = layout.offsetX + c * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                    let centerY = layout.offsetY + r * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                    farmFloatingTexts.push(new FloatingText(centerX, centerY, '+', '#27ae60'));
                }
            }
        }
        if (total > 0) {
            bankSeeds += total;
            farmFloatingTexts.push(new FloatingText(canvas.width / 2, canvas.height / 2, '+' + total + ' \u{1F33B}', '#f39c12'));
            saveData();
            updateFarmUI();
        }
    }

    function expandFarm() {
        if (farmRows >= FARM_CONFIG.maxRows || bankSeeds < FARM_CONFIG.expansionCost) return;
        bankSeeds -= FARM_CONFIG.expansionCost;
        farmRows++;
        for (let i = 0; i < FARM_CONFIG.initialCols; i++) {
            farmPlots.push({ state: 'empty', stageStartedAt: 0, watered: false });
        }
        saveData();
        updateFarmUI();
    }

    function updateWorkerSlider() {
        let slider = document.getElementById('workerSlider');
        let newCount = parseInt(slider.value);
        let totalAvailable = farmWorkers + bankFriends;
        if (newCount > totalAvailable) newCount = totalAvailable;
        bankFriends = totalAvailable - newCount;
        farmWorkers = newCount;
        document.getElementById('workerTakeCount').innerText = farmWorkers;
        let wLayout = getFarmGridLayout();
        let wGroundY = wLayout.offsetY + wLayout.gridHeight + 50;
        while (farmWorkerHamsters.length < Math.min(farmWorkers, 10)) {
            let wStartX = wLayout.offsetX + Math.random() * wLayout.gridWidth;
            let nw = new FarmWorkerHamster(wStartX, wGroundY);
            nw.groundY = wGroundY;
            farmWorkerHamsters.push(nw);
        }
        while (farmWorkerHamsters.length > Math.min(farmWorkers, 10)) farmWorkerHamsters.pop();
        saveData();
        updateFarmUI();
    }

    function performWorkerActions() {
        let layout = getFarmGridLayout();
        let available = farmWorkerHamsters.filter(w => !w.hasTask());
        if (available.length === 0) return;
        let wi = 0;

        for (let i = 0; i < farmPlots.length && wi < available.length; i++) {
            let plot = farmPlots[i];
            if (plot.state !== 'empty' && plot.state !== 'harvestable' && !plot.watered) {
                if (farmWorkerHamsters.some(w => w.hasTask() && w.targetPlotIdx === i)) continue;
                let r = Math.floor(i / layout.cols);
                let c = i % layout.cols;
                let cx = layout.offsetX + c * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                let cy = layout.offsetY + r * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                available[wi].assignTask(i, 'water', cx, cy);
                wi++;
            }
        }

        for (let i = 0; i < farmPlots.length && wi < available.length; i++) {
            let plot = farmPlots[i];
            if (plot.state === 'empty' && bankSeeds >= FARM_CONFIG.plantCost) {
                if (farmWorkerHamsters.some(w => w.hasTask() && w.targetPlotIdx === i)) continue;
                let r = Math.floor(i / layout.cols);
                let c = i % layout.cols;
                let cx = layout.offsetX + c * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                let cy = layout.offsetY + r * (layout.cellSize + layout.gap) + layout.cellSize / 2;
                available[wi].assignTask(i, 'plant', cx, cy);
                wi++;
            }
        }
    }

    function updatePageIndicator(page) {
        let indicator = document.getElementById('pageIndicator');
        indicator.style.display = 'flex';
        document.getElementById('dotNest').className = 'page-dot' + (page === 'nest' ? ' active' : '');
        document.getElementById('dotFarm').className = 'page-dot' + (page === 'farm' ? ' active' : '');
    }

    // ==========================================
    // â–¼â–¼â–¼ ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
    // ==========================================
    let isPlaying = false;
    let score = 0;
    let seedsCollected = 0;
    let gravity = 0.6;
    let speed = 7;
    let nextFriendScoreTarget = 1000;
    let spawnFriendFlag = false;
    let playerHistory = []; 

    function getMaxSeedCapacity() { return (1 + followers.length) * SEED_CAPACITY_PER_HAMSTER; }

    const player = {
        x: 150, y: 0, width: 68, height: 68, dy: 0, jumpPower: -13, color: '#ff3f34', isGrounded: false, jumpCount: 0, maxJumps: 2,
        draw: function() {
            let img = sprites.run.loaded ? sprites.run.img : null;
            let bobY = 0;
            if (!this.isGrounded) {
                if (this.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                else img = sprites.jump.loaded ? sprites.jump.img : img;
            } else {
                bobY = Math.sin(Date.now() / 13) * 1;
            }
            if(img) ctx.drawImage(img, this.x, this.y + bobY, this.width, this.height);
            else { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y + bobY, this.width, this.height); }
        },
        update: function() {
            this.dy += gravity; this.y += this.dy;
            if (this.y > canvas.height) gameOver();
        },
        jump: function() {
            if (this.isGrounded || this.jumpCount < this.maxJumps) {
                this.dy = this.jumpPower; this.jumpCount++; this.isGrounded = false;
                if (this.jumpCount === 2) this.dy = this.jumpPower * 0.9;
            } else if (followers.length > 0) {
                this.dy = this.jumpPower; this.isGrounded = false;
                followers.shift(); detachedFriends.push(new DetachedFriend(this.x, this.y + this.height));
                let currentMax = getMaxSeedCapacity(); if (seedsCollected > currentMax) seedsCollected = currentMax; updateSeedDisplay();
            }
        },
        land: function(y) { this.y = y - this.height; this.dy = 0; this.isGrounded = true; this.jumpCount = 0; }
    };

    class DetachedFriend {
        constructor(x, y) { this.x = x; this.y = y; this.width = 68; this.height = 68; this.dy = 5; this.isDead = false; }
        update() { this.dy += gravity; this.y += this.dy; this.x -= speed; }
        draw() {
            if (sprites.fall.loaded) {
                ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); 
                ctx.rotate(Math.random()); 
                ctx.drawImage(sprites.fall.img, -this.width/2, -this.height/2, this.width, this.height); ctx.restore();
            } else { ctx.fillStyle = '#ff6b6b'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
    }
    let detachedFriends = [];
    class Seed {
        constructor(x, y) { this.x = x; this.y = y; this.width = 15; this.height = 20; this.collected = false; }
        draw() {
            if (this.collected) return;
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(this.x + this.width/2, this.y + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2); ctx.fill(); }
        }
        update() { this.x -= speed; }
    }
    let seeds = [];
    class Collectible {
        constructor(x, y) { this.x = x; this.y = y; this.width = 68; this.height = 68; }
        draw() {
            ctx.globalAlpha = 1.0;
            if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = '#feca57'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
        update() { this.x -= speed; }
    }
    let collectibles = []; let followers = []; let platforms = [];
    function getRandomPattern() {
        let totalWeight = 0; for (let key in SPAWN_PATTERNS) totalWeight += SPAWN_PATTERNS[key].weight;
        let random = Math.random() * totalWeight; let currentWeight = 0;
        for (let key in SPAWN_PATTERNS) { currentWeight += SPAWN_PATTERNS[key].weight; if (random < currentWeight) return SPAWN_PATTERNS[key]; }
        return SPAWN_PATTERNS.normal;
    }
    class SlopePlatform {
        constructor(x, y, width, slopeType) {
            this.x = x; this.y = y; this.width = width; this.slopeType = slopeType;
            const heightDiff = width * 0.5;
            if (slopeType === 1) { this.endY = this.y - heightDiff; this.slopeFactor = -heightDiff / width; }
            else if (slopeType === -1) { this.endY = this.y + heightDiff; this.slopeFactor = heightDiff / width; }
            else { this.endY = this.y; this.slopeFactor = 0; }
            this.pillars = []; let currentX = 0;
            while (currentX < this.width) {
                let w = PILLAR_CONFIG.minWidth + Math.random() * (PILLAR_CONFIG.maxWidth - PILLAR_CONFIG.minWidth);
                let g = PILLAR_CONFIG.minGap + Math.random() * (PILLAR_CONFIG.maxGap - PILLAR_CONFIG.minGap);
                if (currentX + w > this.width) w = this.width - currentX;
                let pillarTopY = this.y + (currentX * this.slopeFactor);
                this.pillars.push({ relX: currentX, endRelX: currentX + w, y: pillarTopY, w: w }); currentX += w + g;
            }
        }
        getPillarHeightAt(targetX) {
            let relX = targetX - this.x; if (relX < 0 || relX > this.width) return null;
            for (let p of this.pillars) { if (relX >= p.relX && relX <= p.endRelX) return p.y; } return null;
        }
        draw() {
            ctx.fillStyle = PILLAR_CONFIG.baseColor;
            for (let p of this.pillars) {
                let drawX = this.x + p.relX; if (drawX > canvas.width || drawX + p.w < 0) continue;
                ctx.fillRect(drawX, p.y, p.w, canvas.height - p.y);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.endY); ctx.stroke();
        }
        update() { this.x -= speed; }
    }
    function addPlatform(x, pattern) {
        const width = pattern.width.min + Math.random() * (pattern.width.max - pattern.width.min);
        let lastEndY = platforms.length > 0 ? platforms[platforms.length - 1].endY : canvas.height / 2;
        let startY = lastEndY + (Math.random() * 200 - 100); 
        if (startY < 150) startY = 150; if (startY > canvas.height - 150) startY = canvas.height - 150;
        const r = Math.random(); let type = 0;
        if (r < 0.4) type = 1; else if (r < 0.7) type = -1; else type = 0;
        if (startY < 200) type = -1; if (startY > canvas.height - 200) type = 1;
        const newPlatform = new SlopePlatform(x, startY, width, type); platforms.push(newPlatform);
        let seedInterval = 60; let currentSeedX = 30;
        while (currentSeedX < width - 30) {
            if (Math.random() < 0.7) {
                let isAir = Math.random() < 0.3;
                let groundY = newPlatform.y + (currentSeedX * newPlatform.slopeFactor);
                let seedY = isAir ? groundY - 100 - (Math.random() * 50) : groundY - 25; 
                let seedX = newPlatform.x + currentSeedX; seeds.push(new Seed(seedX, seedY));
            }
            currentSeedX += seedInterval;
        }
        if (spawnFriendFlag) {
            let centerX = width / 2; let centerY = newPlatform.y + (centerX * newPlatform.slopeFactor);
            let itemY = centerY - 45; 
            let itemX = x + centerX;
            collectibles.push(new Collectible(itemX, itemY)); spawnFriendFlag = false;
        }
    }
    function gameLoop() {
        if (gameState !== 'playing') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        player.update();
        // â˜…ä¿®æ­£ï¼šè¶³å…ƒã®ä½ç½®ã‚’è¨˜éŒ²
        playerHistory.unshift({ footY: player.y + player.height, isGrounded: player.isGrounded, jumpCount: player.jumpCount }); 
        let maxHistory = (followers.length + 1) * 15; if (playerHistory.length > maxHistory + 100) playerHistory.length = maxHistory + 100;
        if (score >= nextFriendScoreTarget) { spawnFriendFlag = true; nextFriendScoreTarget += (FRIEND_INTERVAL_METER * 10); }
        if (platforms.length === 0 || platforms[platforms.length - 1].x < canvas.width - 50) {
            if (platforms.length === 0) addPlatform(0, SPAWN_PATTERNS.normal);
            else {
                let pattern = getRandomPattern();
                let gap = pattern.gap.min + Math.random() * (pattern.gap.max - pattern.gap.min);
                let lastPlatform = platforms[platforms.length - 1];
                let spawnX = lastPlatform.x + lastPlatform.width + gap;
                addPlatform(spawnX, pattern);
            }
        }
        player.isGrounded = false;
        for (let i = 0; i < platforms.length; i++) {
            let plat = platforms[i]; plat.update(); plat.draw();
            if (player.x + player.width > plat.x && player.x < plat.x + plat.width) {
                let footX = player.x + player.width / 2; let pillarY = plat.getPillarHeightAt(footX);
                if (pillarY !== null) { if (player.y + player.height >= pillarY - 10 && player.y + player.height <= pillarY + 30 && player.dy >= 0) player.land(pillarY); }
            }
            for (let j = 0; j < detachedFriends.length; j++) {
                let df = detachedFriends[j];
                if (!df.isDead && df.x + df.width > plat.x && df.x < plat.x + plat.width) {
                    let dfFootX = df.x + df.width / 2; let dfPillarY = plat.getPillarHeightAt(dfFootX);
                    if (dfPillarY !== null) {
                        if (df.y + df.height >= dfPillarY - 10 && df.y + df.height <= dfPillarY + 30 && df.dy >= 0) { 
                            followers.push({}); 
                            df.isDead = true; 
                            updateSeedDisplay(); 
                        }
                    }
                }
            }
            if (plat.x + plat.width < 0) { platforms.splice(i, 1); i--; }
        }
        for (let i = 0; i < detachedFriends.length; i++) {
            let df = detachedFriends[i]; df.update(); df.draw();
            if (df.y > canvas.height || df.x + df.width < 0 || df.isDead) { detachedFriends.splice(i, 1); i--; }
        }
        for (let i = 0; i < seeds.length; i++) {
            let seed = seeds[i]; seed.update(); seed.draw();
            if (!seed.collected && player.x < seed.x + seed.width && player.x + player.width > seed.x && player.y < seed.y + seed.height && player.y + player.height > seed.y) {
                let currentMax = getMaxSeedCapacity();
                if (seedsCollected < currentMax) { seed.collected = true; seedsCollected++; updateSeedDisplay(); }
            }
            if (seed.x + seed.width < 0 || (seed.collected && seed.x < player.x - 200)) { seeds.splice(i, 1); i--; }
        }
        for (let i = 0; i < collectibles.length; i++) {
            let item = collectibles[i]; item.update(); item.draw();
            if (player.x < item.x + item.width && player.x + player.width > item.x && player.y < item.y + item.height && player.y + player.height > item.y) {
                followers.push({}); collectibles.splice(i, 1); i--; updateSeedDisplay();
            } else if (item.x + item.width < 0) { collectibles.splice(i, 1); i--; }
        }
        for (let i = 0; i < followers.length; i++) {
            // â˜…ä¿®æ­£ï¼šãƒ•ãƒ¬ãƒ¼ãƒ é…å»¶ã¨ã‚¹ãƒ”ãƒ¼ãƒ‰ã‹ã‚‰Xåº§æ¨™ã‚’è¨ˆç®—
            let delayFrame = 7 * (i + 1);
            let size = 68;
            let pastState = playerHistory[delayFrame] || playerHistory[playerHistory.length-1];
            
            if (pastState) {
                let followX = player.x - (delayFrame * speed);
                let drawY = pastState.footY - size;
                let bobY = 0;

                if (followX > -100) {
                    let img = sprites.run.loaded ? sprites.run.img : null;
                    if (!pastState.isGrounded) {
                        if (pastState.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                        else img = sprites.jump.loaded ? sprites.jump.img : img;
                    } else {
                        bobY = Math.sin(Date.now() / 13 + (i + 1) * 1.2) * 1;
                    }
                    if(img) ctx.drawImage(img, followX, drawY + bobY, size, size);
                    else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(followX, drawY + bobY, size, size); }
                }
            } else {
                let followX = player.x - ((i + 1) * 50);
                let bobY = Math.sin(Date.now() / 13 + (i + 1) * 1.2) * 1;
                if(sprites.run.loaded) ctx.drawImage(sprites.run.img, followX, player.y + bobY, size, size);
                else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(followX, player.y + bobY, size, size); }
            }
        }
        player.draw(); score++; document.getElementById('score').innerText = 'Distance: ' + Math.floor(score / 10) + 'm';
        requestAnimationFrame(gameLoop);
    }
    
    // Input Handling
    let touchStartX = 0; let touchStartY = 0;
    
    // ãƒ‰ãƒ©ãƒƒã‚°ã®é€Ÿåº¦è¨ˆç®—ç”¨
    let lastDragX = 0;
    let lastDragY = 0;
    let dragVelocityX = 0;
    let dragVelocityY = 0;

    function handleInputStart(e) {
        if (!gameStarted) return; 
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
        
        let cx, cy;
        if(e.type === 'touchstart') { 
            e.preventDefault(); 
            touchStartX = e.touches[0].clientX; 
            touchStartY = e.touches[0].clientY; 
        } else { 
            touchStartX = e.clientX; 
            touchStartY = e.clientY; 
        }
        
        // åº§æ¨™è¨ˆç®—
        let rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width;
        let scaleY = canvas.height / rect.height;
        cx = (touchStartX - rect.left) * scaleX;
        cy = (touchStartY - rect.top) * scaleY;

        if (gameState === 'nest') {
            // â˜…ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®æ´ã¿åˆ¤å®š
            for(let h of nestHamsters) {
                let dx = h.x - cx; 
                let dy = (h.y - h.size/2) - cy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < h.size) {
                    draggedHamster = h;
                    h.isDragging = true;
                    h.isThrown = false;
                    h.vx = 0; h.vy = 0;
                    dragOffsetX = h.x - cx;
                    dragOffsetY = (h.y - h.size/2) - cy;
                    lastDragX = cx; lastDragY = cy;
                    return; // ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’æ´ã‚“ã ã‚‰ç¨®åˆ¤å®šã¯ã—ãªã„
                }
            }

            // ç¨®ã®ç‰©ç†ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ—¢å­˜ï¼‰
            for(let s of nestSeeds) {
                let dx = s.x - cx; let dy = s.y - cy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 100) {
                    let force = (100 - dist) * 0.2; s.wakeUp();
                    s.vx += (dx/dist) * force + (Math.random()-0.5)*5; s.vy -= force * 0.5 + Math.random()*5;
                }
            }
        }
        else if (gameState === 'farm') {
            for (let h of farmWorkerHamsters) {
                let dx = h.x - cx;
                let dy = h.y - cy;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < h.size) {
                    draggedHamster = h;
                    h.isDragging = true;
                    h.isThrown = false;
                    h.vx = 0; h.vy = 0;
                    h.state = 'idle';
                    h.targetPlotIdx = -1;
                    dragOffsetX = h.x - cx;
                    dragOffsetY = h.y - cy;
                    lastDragX = cx; lastDragY = cy;
                    return;
                }
            }
            handleFarmTap(cx, cy);
        }
        else if (gameState === 'playing') player.jump();
    }

    // â˜…è¿½åŠ : ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ç§»å‹•å‡¦ç†
    function handleInputMove(e) {
        if (!draggedHamster || (gameState !== 'nest' && gameState !== 'farm')) return;
        e.preventDefault();

        let cx, cy;
        if(e.type === 'touchmove') {
            cx = e.touches[0].clientX;
            cy = e.touches[0].clientY;
        } else {
            cx = e.clientX;
            cy = e.clientY;
        }

        let rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width;
        let scaleY = canvas.height / rect.height;
        let gameX = (cx - rect.left) * scaleX;
        let gameY = (cy - rect.top) * scaleY;

        draggedHamster.x = gameX + dragOffsetX;
        if (gameState === 'nest') {
            draggedHamster.y = gameY + dragOffsetY + draggedHamster.size / 2;
        } else {
            draggedHamster.y = gameY + dragOffsetY;
        }

        // æŠ•ã’ã‚‹é€Ÿåº¦ã®è¨ˆç®— (ç°¡æ˜“çš„ãªå·®åˆ†)
        dragVelocityX = (gameX - lastDragX) * 0.5;
        dragVelocityY = (gameY - lastDragY) * 0.5;
        lastDragX = gameX;
        lastDragY = gameY;
    }

    function handleInputEnd(e) {
        if ((gameState === 'nest' || gameState === 'farm') && draggedHamster) {
            draggedHamster.isDragging = false;
            draggedHamster.isThrown = true;
            draggedHamster.vx = Math.max(-20, Math.min(20, dragVelocityX));
            draggedHamster.vy = Math.max(-20, Math.min(20, dragVelocityY));
            draggedHamster = null;
            return;
        }

        let touchEndX = 0; let touchEndY = 0;
        if(e.type === 'touchend') { touchEndX = e.changedTouches[0].clientX; touchEndY = e.changedTouches[0].clientY; }
        else { touchEndX = e.clientX; touchEndY = e.clientY; }
        let diffX = touchEndX - touchStartX; let diffY = touchEndY - touchStartY;

        if (gameState === 'nest') {
            if (diffX < -50 && Math.abs(diffX) > Math.abs(diffY)) initFarm();
        } else if (gameState === 'farm') {
            if (diffX > 50 && Math.abs(diffX) > Math.abs(diffY)) initNest();
        } else if (gameState === 'playing') {
            if (diffX < -50 && Math.abs(diffX) > Math.abs(diffY)) pauseGame();
        }
    }

    window.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove); // è¿½åŠ 
    window.addEventListener('mouseup', handleInputEnd);
    
    window.addEventListener('touchstart', handleInputStart, {passive: false});
    window.addEventListener('touchmove', handleInputMove, {passive: false}); // è¿½åŠ 
    window.addEventListener('touchend', handleInputEnd);

    function updateSeedDisplay() {
        let currentMax = getMaxSeedCapacity();
        document.getElementById('seedCount').innerText = `Seeds: ${seedsCollected} / ${currentMax}`;
    }

    function pauseGame() { if (gameState !== 'playing') return; gameState = 'paused'; document.getElementById('pauseModal').style.display = 'block'; }
    
    function confirmGoHome() { 
        gameState = 'nest'; 
        let log = processTimePassage(seedsCollected, followers.length);
        document.getElementById('logContent').innerHTML = log.join('<br>');
        document.getElementById('logModal').style.display = 'block';
        document.getElementById('pauseModal').style.display = 'none'; 
        initNest(); 
    }
    function closeLog() { document.getElementById('logModal').style.display = 'none'; }
    function cancelGoHome() { gameState = 'playing'; document.getElementById('pauseModal').style.display = 'none'; gameLoop(); }
    
    function gameOver() {
        gameState = 'gameover'; 
        saveData();
        const modal = document.getElementById('gameOverModal');
        const text = document.getElementById('overlayText');
        text.innerHTML = `<h2>Game Over</h2><p>Distance: ${Math.floor(score / 10)}m</p><p>ç¨®ãƒ­ã‚¹ãƒˆ: ${seedsCollected}</p><p style="font-size:14px; color:#aaa;">ä»²é–“ã¨ã¯ãã‚Œã¦ã—ã¾ã£ãŸ...</p>`;
        modal.style.display = 'block';
    }
    function resetGame(initialFollowersCount = 0) {
        gameState = 'playing';
        document.getElementById('gameOverModal').style.display = 'none'; document.getElementById('pauseModal').style.display = 'none'; document.getElementById('instruction').style.display = 'none';
        platforms = []; seeds = []; collectibles = []; followers = []; detachedFriends = []; playerHistory = [];
        player.x = 150; player.y = canvas.height / 2; player.width = 68; player.height = 68; player.dy = 0; player.jumpCount = 0; player.color = '#ff3f34';
        // â˜…ä¿®æ­£ï¼šåˆæœŸå±¥æ­´ã‚’æ­£ã—ãåŸ‹ã‚ã‚‹
        for(let i=0; i<initialFollowersCount; i++){ 
            followers.push({}); 
            for(let j=0; j<15; j++) playerHistory.push({footY: player.y + player.height, isGrounded:true, jumpCount:0}); 
        }
        spawnFriendFlag = false; nextFriendScoreTarget = 1000; seedsCollected = 0; 
        updateSeedDisplay();
        platforms.push(new SlopePlatform(0, canvas.height / 2 + 100, canvas.width, 0));
        score = 0; document.getElementById('score').innerText = 'Distance: 0m';
        gameLoop();
    }
</script>
</body>
</html>
