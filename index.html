<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hamster Adventure Final Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e272e;
            font-family: sans-serif;
            touch-action: none; /* ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ãƒƒãƒæ“ä½œã‚’ç„¡åŠ¹åŒ– */
            user-select: none;
            -webkit-user-select: none;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-layer {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            width: 100%;
            height: 100%;
            top: 0; left: 0;
        }
        .ui-text {
            position: absolute;
            right: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            text-align: right;
        }
        #score { top: 20px; font-size: 24px; color: #00d8d6; }
        #seedCount { top: 50px; font-size: 24px; color: #feca57; }
        #flickHint {
            top: 85px; 
            font-size: 16px; 
            color: #fff; 
            opacity: 0.8;
            background-color: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .btn {
            pointer-events: auto;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 0 #999;
            margin: 5px;
        }
        .btn:active {
            box-shadow: 0 2px 0 #999;
            transform: translateY(2px);
        }
        .btn:disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            color: #fff;
            z-index: 80;
            display: none;
            width: 80%;
            max-width: 320px;
            border: 2px solid #fff;
        }

        #nestUI {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 500px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            z-index: 50;
            display: none;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
        }
        #nestStats {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2d3436;
            line-height: 1.6;
            text-align: left;
            padding: 0 10px;
        }
        .breed-info {
            font-size: 14px;
            color: #d63031;
            font-weight: bold;
        }
        .slider-container { margin: 10px 0; text-align: left; padding: 0 10px; }
        input[type=range] { width: 100%; }
        
        .action-area {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .action-area button {
            flex: 1;
        }

        #instruction {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            text-align: center;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
        }
        
        #logModal { z-index: 90; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #1e272e; color: #fff; display: flex;
            justify-content: center; align-items: center; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loading">Loading...</div>

<div class="ui-layer" id="gameUI">
    <div id="score" class="ui-text">Distance: 0m</div>
    <div id="seedCount" class="ui-text">Seeds: 0 / 100</div>
    <div id="flickHint" class="ui-text">â† ãƒ•ãƒªãƒƒã‚¯ã§å¸°å·£</div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="instruction" style="display:none;">ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</div>

<div id="pauseModal" class="modal">
    <h3>ğŸ  å¸°ã‚Šã¾ã™ã‹ï¼Ÿ</h3>
    <p>ä»Šã®ä»²é–“ã¨ç¨®ã‚’æŒã£ã¦<br>å·£ã«å¸°ã‚Šã¾ã™ã€‚</p>
    <button class="btn" style="background:#ff9f43; color:#fff;" onclick="confirmGoHome()">ã¯ã„ (å¸°ã‚‹)</button>
    <button class="btn" onclick="cancelGoHome()">ã„ã„ãˆ (æˆ»ã‚‹)</button>
</div>

<div id="breedingModal" class="modal">
    <h3>ğŸ’– å®¶æ—ã‚’å¢—ã‚„ã—ã¾ã™ã‹ï¼Ÿ</h3>
    <p style="text-align:left; display:inline-block;">
        <span style="color:#feca57">ğŸŒ» æ¶ˆè²»: ç¨® 600å€‹</span><br>
        <span style="color:#ff9f43">ğŸ¹ è¦ª: 1åŒ¹</span><br>
        <span style="font-size:12px; color:#aaa;">â€»è¦ªã¯è‚²å…ã®ãŸã‚å†’é™ºã«å‡ºã‚‰ã‚Œãªããªã‚Šã¾ã™</span>
    </p>
    <br><br>
    <button class="btn" style="background:#fd79a8; color:#fff;" onclick="confirmBreeding()">ã¯ã„ (ç¹æ®–ã™ã‚‹)</button>
    <button class="btn" onclick="cancelBreeding()">ã„ã„ãˆ (ã‚„ã‚ã‚‹)</button>
</div>

<div id="gameOverModal" class="modal">
    <div id="overlayText"></div>
    <br>
    <button class="btn" onclick="resetGame(selectedFriendsCount)">ãƒªãƒˆãƒ©ã‚¤</button>
    <br><br>
    <button class="btn" onclick="initNest()">å·£ã«æˆ»ã‚‹</button>
</div>

<div id="logModal" class="modal">
    <h3>ğŸ“ å†’é™ºæ—¥èªŒ</h3>
    <div id="logContent" style="text-align: left; margin: 10px 0; font-size: 14px;"></div>
    <button class="btn" onclick="closeLog()">é–‰ã˜ã‚‹</button>
</div>

<div id="nestUI">
    <div id="nestStats">
        <div>ğŸŒ» è²¯è”µç¨®: <b id="bankSeeds" style="color:#e67e22; font-size:20px;">0</b> å€‹</div>
        <div>ğŸ¹ å¤§äºº: <b id="bankFriends">0</b> åŒ¹ / ğŸ‘¶ å­ãƒãƒ : <b id="babyCount">0</b> åŒ¹</div>
        <div id="pregnantInfo" class="breed-info"></div>
    </div>
    <hr>
    <div class="slider-container">
        <label>é€£ã‚Œã¦è¡Œã: <b id="takeCount">0</b> åŒ¹</label>
        <input type="range" id="friendSlider" min="0" max="0" value="0" oninput="updateSlider()">
    </div>
    <div class="action-area">
        <button id="breedBtn" class="btn" style="background:#fd79a8; color:#fff;" onclick="startBreedingCheck()">ğŸ’– ç¹æ®–</button>
        <button class="btn" style="background:#00cec9; color:#fff;" onclick="departFromNest()">å†’é™ºã¸ï¼</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // â–¼â–¼â–¼ ç”»åƒèª­ã¿è¾¼ã¿ â–¼â–¼â–¼
    const sprites = {
        idle: { img: new Image(), loaded: false },
        run: { img: new Image(), loaded: false },
        jump: { img: new Image(), loaded: false },
        djump: { img: new Image(), loaded: false },
        fall: { img: new Image(), loaded: false },
        seed: { img: new Image(), loaded: false }
    };
    
    sprites.idle.img.src = 'ham.idle.png';
    sprites.run.img.src = 'ham.run.png';
    sprites.jump.img.src = 'ham.jump.png';
    sprites.djump.img.src = 'ham.djump.png';
    sprites.fall.img.src = 'ham.fall.png';
    sprites.seed.img.src = 'seed.png';

    let imagesLoadedCount = 0;
    const totalImages = Object.keys(sprites).length;
    let gameStarted = false;

    function checkAllImagesLoaded() {
        imagesLoadedCount++;
        if (imagesLoadedCount >= totalImages) {
            startGame();
        }
    }

    function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        document.getElementById('loading').style.display = 'none';
        
        // åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã¯å·£ã‚’è¡¨ç¤º
        if (localStorage.getItem('ham_seeds')) initNest(); else initNest();
    }

    for (let key in sprites) {
        sprites[key].img.onload = function() {
            sprites[key].loaded = true;
            checkAllImagesLoaded();
        };
        sprites[key].img.onerror = function() {
            console.warn("Image load failed: " + sprites[key].img.src);
            sprites[key].loaded = false; 
            checkAllImagesLoaded(); 
        };
    }

    // 3ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç”»åƒã‚¨ãƒ©ãƒ¼æ™‚ã‚‚å¼·åˆ¶é–‹å§‹ï¼‰
    setTimeout(() => {
        if (!gameStarted) {
            console.warn("Loading timeout. Force start.");
            startGame();
        }
    }, 3000);


    // ==========================================
    // â–¼â–¼â–¼ è¨­å®šã‚¨ãƒªã‚¢ â–¼â–¼â–¼
    // ==========================================
    const ZOOM_SCALE = 0.6; 
    const FRIEND_INTERVAL_METER = 200; 
    const NEST_FLOOR_OFFSET = 650; 
    const MAX_PHYSICS_SEEDS = 200;
    const SEED_CAPACITY_PER_HAMSTER = 100;
    const BREEDING_COST_SEEDS = 600;
    const BABIES_PER_BIRTH = 6;

    const PILLAR_CONFIG = { minWidth: 10, maxWidth: 10, minGap: 0, maxGap: 0, baseColor: '#0be881' };
    const SPAWN_PATTERNS = {
        normal: { name: "åŸºæœ¬ãƒ¢ãƒ¼ãƒ‰", weight: 60, width: { min: 300, max: 600 }, gap: { min: 50, max: 150 } },
        rapid: { name: "é€£æ‰“ãƒ¢ãƒ¼ãƒ‰", weight: 30, width: { min: 30, max: 150 }, gap: { min: 30, max: 80 } },
        longJump: { name: "å¤§ã‚¸ãƒ£ãƒ³ãƒ—ãƒ¢ãƒ¼ãƒ‰", weight: 10, width: { min: 200, max: 400 }, gap: { min: 180, max: 500 } }
    };

    function resize() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        canvas.width = screenWidth / ZOOM_SCALE;
        canvas.height = screenHeight / ZOOM_SCALE;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // â–¼â–¼â–¼ çŠ¶æ…‹ãƒ»ãƒ‡ãƒ¼ã‚¿ç®¡ç† â–¼â–¼â–¼
    // ==========================================
    let gameState = 'loading';
    let bankSeeds = parseInt(localStorage.getItem('ham_seeds') || '0');
    let bankFriends = parseInt(localStorage.getItem('ham_friends') || '0');
    let breedingQueue = JSON.parse(localStorage.getItem('ham_breeding') || '[]');
    let selectedFriendsCount = 0; 
    
    // ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œç”¨
    let draggedHamster = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function saveData() {
        localStorage.setItem('ham_seeds', bankSeeds);
        localStorage.setItem('ham_friends', bankFriends);
        localStorage.setItem('ham_breeding', JSON.stringify(breedingQueue));
    }

    // ==========================================
    // â–¼â–¼â–¼ ç¹æ®–ãƒ»æ¶ˆè²»ã‚·ã‚¹ãƒ†ãƒ  â–¼â–¼â–¼
    // ==========================================
    function startBreedingCheck() {
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) {
            document.getElementById('breedingModal').style.display = 'block';
        }
    }

    function confirmBreeding() {
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) {
            bankSeeds -= BREEDING_COST_SEEDS;
            bankFriends -= 1; 
            breedingQueue.push({ type: 'pregnant', tripsRemaining: 1, count: 1 });
            saveData(); updateNestUI();
            nestSeeds.splice(0, Math.min(nestSeeds.length, 50)); 
        }
        closeBreedingModal();
    }

    function cancelBreeding() { closeBreedingModal(); }
    function closeBreedingModal() { document.getElementById('breedingModal').style.display = 'none'; }

    function processTimePassage(collectedSeeds, returnedFriendsCount) {
        let log = [];
        bankSeeds += collectedSeeds;
        log.push(`ç¨®ã‚’ ${collectedSeeds} å€‹æŒã¡å¸°ã‚Šã¾ã—ãŸã€‚`);
        
        if (returnedFriendsCount > 0) {
            bankFriends += returnedFriendsCount;
            log.push(`ä»²é–“ ${returnedFriendsCount} åŒ¹ãŒç„¡äº‹ã«å¸°é‚„ã—ã¾ã—ãŸï¼`);
        }

        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        let totalMouths = bankFriends + pregnantCount + babyCount;
        let consumption = totalMouths * 1; 
        log.push(`å·£ã® ${totalMouths} åŒ¹ãŒç¨®ã‚’ ${consumption} å€‹é£Ÿã¹ã¾ã—ãŸã€‚`);

        if (bankSeeds >= consumption) { bankSeeds -= consumption; } else {
            let survivors = bankSeeds; let casualties = totalMouths - survivors;
            bankSeeds = 0; 
            log.push(`<span style="color:red">ç¨®ãŒè¶³ã‚Šãªã„ï¼ ${casualties} åŒ¹ãŒé¤“æ­»ã—ã¾ã—ãŸ...</span>`);
            for (let i = breedingQueue.length - 1; i >= 0; i--) {
                if (casualties <= 0) break; let group = breedingQueue[i];
                if (group.count <= casualties) { casualties -= group.count; breedingQueue.splice(i, 1); }
                else { group.count -= casualties; casualties = 0; }
            }
            if (casualties > 0) { bankFriends = Math.max(0, bankFriends - casualties); }
        }

        let newAdults = 0; let newBabies = 0;
        for (let i = 0; i < breedingQueue.length; i++) {
            let group = breedingQueue[i]; group.tripsRemaining--;
            if (group.tripsRemaining <= 0) {
                if (group.type === 'pregnant') {
                    bankFriends += group.count; let babies = group.count * BABIES_PER_BIRTH; newBabies += babies;
                    group.type = 'baby'; group.count = babies; 
                    group.tripsRemaining = 2; 
                } else if (group.type === 'baby') {
                    newAdults += group.count; bankFriends += group.count; group.done = true; 
                }
            }
        }
        breedingQueue = breedingQueue.filter(q => !q.done);
        if (newBabies > 0) log.push(`ğŸ‘¶ <span style="color:#fd79a8">èµ¤ã¡ã‚ƒã‚“ãŒ ${newBabies} åŒ¹ç”Ÿã¾ã‚Œã¾ã—ãŸï¼</span>`);
        if (newAdults > 0) log.push(`ğŸ¹ <span style="color:#00cec9">å­ãƒãƒ  ${newAdults} åŒ¹ãŒå¤§äººã«ãªã‚Šã¾ã—ãŸï¼</span>`);
        
        saveData(); return log;
    }

    // ==========================================
    // â–¼â–¼â–¼ å·£ã®æç”»ãƒ»UI â–¼â–¼â–¼
    // ==========================================
    let nestHamsters = []; let nestSeeds = []; 

    class PhysicsSeed {
        constructor(x, y) {
            this.x = x; this.y = y; this.physRadius = 5; this.drawRadius = 12; 
            this.vx = (Math.random() - 0.5) * 5; this.vy = Math.random() * 5;
            this.rotation = Math.random() * Math.PI * 2; this.sleeping = false; 
        }
        wakeUp() { this.sleeping = false; }
        update() {
            if (this.sleeping) return; 
            this.vy += 0.5; this.x += this.vx; this.y += this.vy;
            this.vx *= 0.95; this.vy *= 0.95;
            let floorY = canvas.height - NEST_FLOOR_OFFSET;
            if (this.y + this.physRadius > floorY) { this.y = floorY - this.physRadius; this.vy *= -0.3; this.vx *= 0.7; }
            if (this.x - this.physRadius < 0) { this.x = this.physRadius; this.vx *= -0.5; }
            if (this.x + this.physRadius > canvas.width) { this.x = canvas.width - this.physRadius; this.vx *= -0.5; }
            if (Math.abs(this.vx) < 0.05 && Math.abs(this.vy) < 0.1 && this.y > floorY - this.physRadius - 5) { this.vx = 0; this.vy = 0; this.sleeping = true; }
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation + this.x * 0.1); 
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, -10, -12, 20, 25);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(0, 0, 10, 12, 0, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        }
    }

    class NestHamster {
        constructor(stage = 0) { 
            this.stage = stage;
            this.x = Math.random() * canvas.width;
            
            // â˜…ä¿®æ­£: Yåº§æ¨™ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ†æ•£ã•ã›ã¦è¦‹ä¸‹ã‚ã—æ„Ÿã‚’å‡ºã™
            let floorTop = canvas.height - NEST_FLOOR_OFFSET;
            let depthRange = 250; // å¥¥è¡Œãã®ç¯„å›²
            this.y = floorTop + Math.random() * depthRange; 
            this.groundY = this.y; // å€‹åˆ¥ã®åœ°é¢ã®é«˜ã•ã‚’è¨˜æ†¶

            if (this.stage === 2) { 
                this.size = 40; this.state = 'newborn'; 
            } else if (this.stage === 1) { 
                this.size = 65; this.state = 'idle'; 
            } else { 
                this.size = 90; this.state = 'idle'; 
            }

            this.timer = Math.random() * 60; 
            this.vx = 0; 
            this.vy = 0; 
            this.flip = false; 
            this.lastFlip = false;
            this.hopOffset = Math.random() * Math.PI;
            
            this.isDragging = false;
            this.isThrown = false; 
        }

        update() {
            if (this.isDragging) return;

            // â˜…ä¿®æ­£: ç‰©ç†æ¼”ç®—ã®ç€åœ°åˆ¤å®šã‚’å€‹åˆ¥ã® groundY åŸºæº–ã«ã™ã‚‹
            if (this.isThrown || this.y < this.groundY) {
                this.vy += 0.5; 
                this.x += this.vx;
                this.y += this.vy;

                if (this.y > this.groundY) {
                    this.y = this.groundY;
                    this.vy *= -0.5; 
                    this.vx *= 0.8;  
                    if (Math.abs(this.vy) < 1) {
                        this.isThrown = false;
                        this.vy = 0;
                    }
                }
                if (this.x < 0) { this.x = 0; this.vx *= -0.7; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.7; }
                
                if(Math.abs(this.vx) > 1) this.flip = this.vx < 0;

                this.interactWithSeeds();
                return;
            }

            if (this.stage === 2) return; 

            this.timer--;
            if (this.timer <= 0) {
                if (this.state === 'idle') {
                    this.state = 'move'; this.timer = 10 + Math.random() * 30; 
                    let baseSpeed = (this.stage === 1) ? 6 : 4; 
                    let speed = baseSpeed + Math.random() * 3;
                    this.vx = (Math.random() < 0.5) ? speed : -speed; 
                } else {
                    this.state = 'idle'; this.timer = 20 + Math.random() * 60; this.vx = 0;
                }
            }
            this.x += this.vx;
            if (this.x < 0) { this.x = 0; this.vx *= -1; }
            if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -1; }
            
            if (this.vx !== 0) {
                this.lastFlip = this.vx < 0; 
            }
            this.flip = this.lastFlip;

            if (this.state === 'move') {
                this.interactWithSeeds();
            }
        }

        interactWithSeeds() {
            let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed < 1.0) return;

            for (let s of nestSeeds) {
                let dx = s.x - this.x; let dy = s.y - (this.y - this.size/2);
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < this.size * 0.6) { 
                    s.wakeUp(); 
                    let angle = Math.atan2(dy, dx); 
                    let kickPower = speed * 0.3; 
                    if (kickPower > 10) kickPower = 10;
                    s.vx += Math.cos(angle) * kickPower; 
                    s.vy += Math.sin(angle) * kickPower - 0.5; 
                }
            }
        }

        draw() {
            let hopY = 0;
            if (!this.isThrown && !this.isDragging) {
                if (this.stage === 2) {
                    if (Math.random() < 0.02) hopY = -5; 
                } else {
                    hopY = (this.state === 'move') ? Math.sin(Date.now() / 20 + this.hopOffset) * 5 : 0; 
                }
            }
            
            ctx.save(); 
            ctx.translate(this.x, this.y - this.size/2 + hopY);
            if (this.isDragging) ctx.scale(1.1, 1.1);
            if (this.flip) ctx.scale(-1, 1);
            
            let img = sprites.idle.loaded ? sprites.idle.img : null;
            if (this.state === 'move' && !this.isDragging && !this.isThrown && sprites.run.loaded) img = sprites.run.img;
            if ((this.isThrown || this.isDragging) && sprites.fall.loaded) img = sprites.fall.img;
            if (this.stage === 2 && sprites.idle.loaded) img = sprites.idle.img;
            
            if (img) ctx.drawImage(img, -this.size/2, -this.size/2, this.size, this.size);
            else { ctx.fillStyle = this.stage === 2 ? '#fab1a0' : '#ff9f43'; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); }
            ctx.restore();
        }
    }

    function initNest() {
        gameState = 'nest';
        document.getElementById('nestUI').style.display = 'block';
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('gameOverModal').style.display = 'none';
        document.getElementById('pauseModal').style.display = 'none';
        document.getElementById('breedingModal').style.display = 'none';
        document.getElementById('instruction').style.display = 'none';
        updateNestUI();
        nestHamsters = [];
        
        let displayAdults = Math.min(bankFriends, 30);
        for(let i=0; i<displayAdults; i++) nestHamsters.push(new NestHamster(0)); 
        
        breedingQueue.forEach(q => {
            if(q.type === 'baby') {
                let stage = q.tripsRemaining; 
                let count = Math.min(q.count, 20);
                for(let i=0; i<count; i++) nestHamsters.push(new NestHamster(stage));
            }
        });

        nestSeeds = [];
        let physicsCount = Math.min(bankSeeds, MAX_PHYSICS_SEEDS);
        for (let i = 0; i < physicsCount; i++) {
            let dropX = (canvas.width / 2) + (Math.random() - 0.5) * 40;
            nestSeeds.push(new PhysicsSeed(dropX, -Math.random() * 500));
        }
        nestLoop();
    }

    function updateNestUI() {
        document.getElementById('bankSeeds').innerText = bankSeeds;
        let babyCount = 0; let pregnantCount = 0;
        breedingQueue.forEach(q => { if (q.type === 'pregnant') pregnantCount += q.count; if (q.type === 'baby') babyCount += q.count; });
        document.getElementById('bankFriends').innerText = bankFriends;
        document.getElementById('babyCount').innerText = babyCount;
        let infoText = ""; if (pregnantCount > 0) infoText += `ğŸ¤° å‡ºç”£å¾…ã¡ã®è¦ª: ${pregnantCount}åŒ¹ `;
        document.getElementById('pregnantInfo').innerText = infoText;
        const breedBtn = document.getElementById('breedBtn');
        if (bankSeeds >= BREEDING_COST_SEEDS && bankFriends >= 1) { breedBtn.disabled = false; breedBtn.style.opacity = 1; } else { breedBtn.disabled = true; breedBtn.style.opacity = 0.5; }
        const slider = document.getElementById('friendSlider'); slider.max = bankFriends;
        if (parseInt(slider.value) > bankFriends) slider.value = bankFriends;
        updateSlider();
    }

    function nestLoop() {
        if (gameState !== 'nest') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffeaa7'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        let floorY = canvas.height - NEST_FLOOR_OFFSET;
        ctx.fillStyle = '#fdcb6e'; ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);
        ctx.fillStyle = '#e1b12c'; ctx.fillRect(0, floorY, canvas.width, 10);
        let excessSeeds = bankSeeds - nestSeeds.length;
        if (excessSeeds > 0) drawStaticSeedPile(canvas.width / 2, floorY, excessSeeds);
        nestSeeds.forEach(s => s.update()); solvePhysics(); nestSeeds.forEach(s => s.draw());
        
        // â˜…ä¿®æ­£: æç”»é †åºã‚’Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆï¼ˆå¥¥ã‹ã‚‰æ‰‹å‰ã¸ï¼‰
        nestHamsters.sort((a, b) => a.y - b.y);
        nestHamsters.forEach(h => { h.update(); h.draw(); });
        
        // â˜…ä¿®æ­£: è‡ªæ©Ÿã‚’å·¨å¤§åŒ–ã—ã€æ‰‹å‰ã«é…ç½®
        let mySize = 150; // ã‚µã‚¤ã‚ºã‚’å¤§ãã(å…ƒ60)
        let myY = floorY + 180; // æ‰‹å‰(ä¸‹)ã«é…ç½®
        ctx.save(); ctx.translate(canvas.width/2 - mySize/2, myY - mySize/2);
        if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, 0, 0, mySize, mySize);
        else { ctx.fillStyle = '#ff3f34'; ctx.fillRect(0, 0, mySize, mySize); }
        ctx.restore();
        requestAnimationFrame(nestLoop);
    }

    function drawStaticSeedPile(x, y, count) {
        let scale = Math.min(count / 1000, 3) + 0.5;
        let width = 200 * scale; let height = 80 * scale;
        ctx.fillStyle = '#d4ac0d'; ctx.beginPath(); ctx.ellipse(x, y + 20, width, height, 0, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#9a7d0a'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`+ ${count} Seeds`, x, y - height/2);
    }

    function solvePhysics() {
        const iter = 4; 
        for (let k = 0; k < iter; k++) {
            for (let i = 0; i < nestSeeds.length; i++) {
                let s1 = nestSeeds[i];
                for (let j = i + 1; j < nestSeeds.length; j++) {
                    let s2 = nestSeeds[j];
                    if (s1.sleeping && s2.sleeping) continue;
                    let dx = s2.x - s1.x; let dy = s2.y - s1.y; let distSq = dx*dx + dy*dy; let minDist = s1.physRadius + s2.physRadius; 
                    if (distSq < minDist * minDist && distSq > 0) {
                        let dist = Math.sqrt(distSq); let overlap = minDist - dist;
                        let forceX = (dx / dist) * overlap * 0.5; let forceY = (dy / dist) * overlap * 0.5;
                        s1.x -= forceX; s1.y -= forceY; s2.x += forceX; s2.y += forceY;
                        let avgVx = (s1.vx + s2.vx) * 0.5; let avgVy = (s1.vy + s2.vy) * 0.5;
                        s1.vx = s1.vx * 0.9 + avgVx * 0.1; s1.vy = s1.vy * 0.9 + avgVy * 0.1; s2.vx = s2.vx * 0.9 + avgVx * 0.1; s2.vy = s2.vy * 0.9 + avgVy * 0.1;
                    }
                }
            }
        }
    }

    function updateSlider() {
        const slider = document.getElementById('friendSlider');
        selectedFriendsCount = parseInt(slider.value);
        document.getElementById('takeCount').innerText = selectedFriendsCount;
    }

    function departFromNest() {
        bankFriends -= selectedFriendsCount; saveData();
        document.getElementById('nestUI').style.display = 'none'; document.getElementById('gameUI').style.display = 'block';
        resetGame(selectedFriendsCount);
    }

    // ==========================================
    // â–¼â–¼â–¼ ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
    // ==========================================
    let isPlaying = false;
    let score = 0;
    let seedsCollected = 0;
    let gravity = 0.6;
    let speed = 7;
    let nextFriendScoreTarget = 1000;
    let spawnFriendFlag = false;
    let playerHistory = []; 

    function getMaxSeedCapacity() { return (1 + followers.length) * SEED_CAPACITY_PER_HAMSTER; }

    const player = {
        x: 150, y: 0, width: 68, height: 68, dy: 0, jumpPower: -13, color: '#ff3f34', isGrounded: false, jumpCount: 0, maxJumps: 2,
        draw: function() {
            let img = sprites.run.loaded ? sprites.run.img : null;
            if (!this.isGrounded) {
                if (this.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                else img = sprites.jump.loaded ? sprites.jump.img : img;
            }
            if(img) ctx.drawImage(img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
        },
        update: function() {
            this.dy += gravity; this.y += this.dy;
            if (this.y > canvas.height) gameOver();
        },
        jump: function() {
            if (this.isGrounded || this.jumpCount < this.maxJumps) {
                this.dy = this.jumpPower; this.jumpCount++; this.isGrounded = false;
                if (this.jumpCount === 2) this.dy = this.jumpPower * 0.9;
            } else if (followers.length > 0) {
                this.dy = this.jumpPower; this.isGrounded = false;
                followers.shift(); detachedFriends.push(new DetachedFriend(this.x, this.y + this.height));
                let currentMax = getMaxSeedCapacity(); if (seedsCollected > currentMax) seedsCollected = currentMax; updateSeedDisplay();
            }
        },
        land: function(y) { this.y = y - this.height; this.dy = 0; this.isGrounded = true; this.jumpCount = 0; }
    };

    class DetachedFriend {
        constructor(x, y) { this.x = x; this.y = y; this.width = 68; this.height = 68; this.dy = 5; this.isDead = false; }
        update() { this.dy += gravity; this.y += this.dy; this.x -= speed; }
        draw() {
            if (sprites.fall.loaded) {
                ctx.save(); ctx.translate(this.x + this.width/2, this.y + this.height/2); 
                ctx.rotate(Math.random()); 
                ctx.drawImage(sprites.fall.img, -this.width/2, -this.height/2, this.width, this.height); ctx.restore();
            } else { ctx.fillStyle = '#ff6b6b'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
    }
    let detachedFriends = [];
    class Seed {
        constructor(x, y) { this.x = x; this.y = y; this.width = 15; this.height = 20; this.collected = false; }
        draw() {
            if (this.collected) return;
            if (sprites.seed.loaded) ctx.drawImage(sprites.seed.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = '#6F4E37'; ctx.beginPath(); ctx.ellipse(this.x + this.width/2, this.y + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2); ctx.fill(); }
        }
        update() { this.x -= speed; }
    }
    let seeds = [];
    class Collectible {
        constructor(x, y) { this.x = x; this.y = y; this.width = 68; this.height = 68; }
        draw() {
            ctx.globalAlpha = 1.0;
            if (sprites.idle.loaded) ctx.drawImage(sprites.idle.img, this.x, this.y, this.width, this.height);
            else { ctx.fillStyle = '#feca57'; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }
        update() { this.x -= speed; }
    }
    let collectibles = []; let followers = []; let platforms = [];
    function getRandomPattern() {
        let totalWeight = 0; for (let key in SPAWN_PATTERNS) totalWeight += SPAWN_PATTERNS[key].weight;
        let random = Math.random() * totalWeight; let currentWeight = 0;
        for (let key in SPAWN_PATTERNS) { currentWeight += SPAWN_PATTERNS[key].weight; if (random < currentWeight) return SPAWN_PATTERNS[key]; }
        return SPAWN_PATTERNS.normal;
    }
    class SlopePlatform {
        constructor(x, y, width, slopeType) {
            this.x = x; this.y = y; this.width = width; this.slopeType = slopeType;
            const heightDiff = width * 0.5;
            if (slopeType === 1) { this.endY = this.y - heightDiff; this.slopeFactor = -heightDiff / width; }
            else if (slopeType === -1) { this.endY = this.y + heightDiff; this.slopeFactor = heightDiff / width; }
            else { this.endY = this.y; this.slopeFactor = 0; }
            this.pillars = []; let currentX = 0;
            while (currentX < this.width) {
                let w = PILLAR_CONFIG.minWidth + Math.random() * (PILLAR_CONFIG.maxWidth - PILLAR_CONFIG.minWidth);
                let g = PILLAR_CONFIG.minGap + Math.random() * (PILLAR_CONFIG.maxGap - PILLAR_CONFIG.minGap);
                if (currentX + w > this.width) w = this.width - currentX;
                let pillarTopY = this.y + (currentX * this.slopeFactor);
                this.pillars.push({ relX: currentX, endRelX: currentX + w, y: pillarTopY, w: w }); currentX += w + g;
            }
        }
        getPillarHeightAt(targetX) {
            let relX = targetX - this.x; if (relX < 0 || relX > this.width) return null;
            for (let p of this.pillars) { if (relX >= p.relX && relX <= p.endRelX) return p.y; } return null;
        }
        draw() {
            ctx.fillStyle = PILLAR_CONFIG.baseColor;
            for (let p of this.pillars) {
                let drawX = this.x + p.relX; if (drawX > canvas.width || drawX + p.w < 0) continue;
                ctx.fillRect(drawX, p.y, p.w, canvas.height - p.y);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.endY); ctx.stroke();
        }
        update() { this.x -= speed; }
    }
    function addPlatform(x, pattern) {
        const width = pattern.width.min + Math.random() * (pattern.width.max - pattern.width.min);
        let lastEndY = platforms.length > 0 ? platforms[platforms.length - 1].endY : canvas.height / 2;
        let startY = lastEndY + (Math.random() * 200 - 100); 
        if (startY < 150) startY = 150; if (startY > canvas.height - 150) startY = canvas.height - 150;
        const r = Math.random(); let type = 0;
        if (r < 0.4) type = 1; else if (r < 0.7) type = -1; else type = 0;
        if (startY < 200) type = -1; if (startY > canvas.height - 200) type = 1;
        const newPlatform = new SlopePlatform(x, startY, width, type); platforms.push(newPlatform);
        let seedInterval = 60; let currentSeedX = 30;
        while (currentSeedX < width - 30) {
            if (Math.random() < 0.7) {
                let isAir = Math.random() < 0.3;
                let groundY = newPlatform.y + (currentSeedX * newPlatform.slopeFactor);
                let seedY = isAir ? groundY - 100 - (Math.random() * 50) : groundY - 25; 
                let seedX = newPlatform.x + currentSeedX; seeds.push(new Seed(seedX, seedY));
            }
            currentSeedX += seedInterval;
        }
        if (spawnFriendFlag) {
            let centerX = width / 2; let centerY = newPlatform.y + (centerX * newPlatform.slopeFactor);
            let itemY = centerY - 45; 
            let itemX = x + centerX;
            collectibles.push(new Collectible(itemX, itemY)); spawnFriendFlag = false;
        }
    }
    function gameLoop() {
        if (gameState !== 'playing') return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        player.update();
        // â˜…ä¿®æ­£ï¼šè¶³å…ƒã®ä½ç½®ã‚’è¨˜éŒ²
        playerHistory.unshift({ footY: player.y + player.height, isGrounded: player.isGrounded, jumpCount: player.jumpCount }); 
        let maxHistory = (followers.length + 1) * 15; if (playerHistory.length > maxHistory + 100) playerHistory.length = maxHistory + 100;
        if (score >= nextFriendScoreTarget) { spawnFriendFlag = true; nextFriendScoreTarget += (FRIEND_INTERVAL_METER * 10); }
        if (platforms.length === 0 || platforms[platforms.length - 1].x < canvas.width - 50) {
            if (platforms.length === 0) addPlatform(0, SPAWN_PATTERNS.normal);
            else {
                let pattern = getRandomPattern();
                let gap = pattern.gap.min + Math.random() * (pattern.gap.max - pattern.gap.min);
                let lastPlatform = platforms[platforms.length - 1];
                let spawnX = lastPlatform.x + lastPlatform.width + gap;
                addPlatform(spawnX, pattern);
            }
        }
        player.isGrounded = false;
        for (let i = 0; i < platforms.length; i++) {
            let plat = platforms[i]; plat.update(); plat.draw();
            if (player.x + player.width > plat.x && player.x < plat.x + plat.width) {
                let footX = player.x + player.width / 2; let pillarY = plat.getPillarHeightAt(footX);
                if (pillarY !== null) { if (player.y + player.height >= pillarY - 10 && player.y + player.height <= pillarY + 30 && player.dy >= 0) player.land(pillarY); }
            }
            for (let j = 0; j < detachedFriends.length; j++) {
                let df = detachedFriends[j];
                if (!df.isDead && df.x + df.width > plat.x && df.x < plat.x + plat.width) {
                    let dfFootX = df.x + df.width / 2; let dfPillarY = plat.getPillarHeightAt(dfFootX);
                    if (dfPillarY !== null) {
                        if (df.y + df.height >= dfPillarY - 10 && df.y + df.height <= dfPillarY + 30 && df.dy >= 0) { 
                            followers.push({}); 
                            df.isDead = true; 
                            updateSeedDisplay(); 
                        }
                    }
                }
            }
            if (plat.x + plat.width < 0) { platforms.splice(i, 1); i--; }
        }
        for (let i = 0; i < detachedFriends.length; i++) {
            let df = detachedFriends[i]; df.update(); df.draw();
            if (df.y > canvas.height || df.x + df.width < 0 || df.isDead) { detachedFriends.splice(i, 1); i--; }
        }
        for (let i = 0; i < seeds.length; i++) {
            let seed = seeds[i]; seed.update(); seed.draw();
            if (!seed.collected && player.x < seed.x + seed.width && player.x + player.width > seed.x && player.y < seed.y + seed.height && player.y + player.height > seed.y) {
                let currentMax = getMaxSeedCapacity();
                if (seedsCollected < currentMax) { seed.collected = true; seedsCollected++; updateSeedDisplay(); }
            }
            if (seed.x + seed.width < 0 || (seed.collected && seed.x < player.x - 200)) { seeds.splice(i, 1); i--; }
        }
        for (let i = 0; i < collectibles.length; i++) {
            let item = collectibles[i]; item.update(); item.draw();
            if (player.x < item.x + item.width && player.x + player.width > item.x && player.y < item.y + item.height && player.y + player.height > item.y) {
                followers.push({}); collectibles.splice(i, 1); i--; updateSeedDisplay();
            } else if (item.x + item.width < 0) { collectibles.splice(i, 1); i--; }
        }
        for (let i = 0; i < followers.length; i++) {
            // â˜…ä¿®æ­£ï¼šãƒ•ãƒ¬ãƒ¼ãƒ é…å»¶ã¨ã‚¹ãƒ”ãƒ¼ãƒ‰ã‹ã‚‰Xåº§æ¨™ã‚’è¨ˆç®—
            let delayFrame = 7 * (i + 1);
            let size = 68;
            let pastState = playerHistory[delayFrame] || playerHistory[playerHistory.length-1];
            
            if (pastState) {
                let followX = player.x - (delayFrame * speed); // ã‚¹ãƒ”ãƒ¼ãƒ‰Ã—æ™‚é–“ã§ä½ç½®è¨ˆç®—
                let drawY = pastState.footY - size;

                if (followX > -100) {
                    let img = sprites.run.loaded ? sprites.run.img : null;
                    if (!pastState.isGrounded) {
                        if (pastState.jumpCount === 2) img = sprites.djump.loaded ? sprites.djump.img : img;
                        else img = sprites.jump.loaded ? sprites.jump.img : img;
                    }
                    if(img) ctx.drawImage(img, followX, drawY, size, size);
                    else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(followX, drawY, size, size); }
                }
            } else {
                let followX = player.x - ((i + 1) * 50);
                if(sprites.run.loaded) ctx.drawImage(sprites.run.img, followX, player.y, size, size);
                else { ctx.fillStyle = '#ff9f43'; ctx.fillRect(followX, player.y, size, size); }
            }
        }
        player.draw(); score++; document.getElementById('score').innerText = 'Distance: ' + Math.floor(score / 10) + 'm';
        requestAnimationFrame(gameLoop);
    }
    
    // Input Handling
    let touchStartX = 0; let touchStartY = 0;
    
    // ãƒ‰ãƒ©ãƒƒã‚°ã®é€Ÿåº¦è¨ˆç®—ç”¨
    let lastDragX = 0;
    let lastDragY = 0;
    let dragVelocityX = 0;
    let dragVelocityY = 0;

    function handleInputStart(e) {
        if (!gameStarted) return; 
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
        
        let cx, cy;
        if(e.type === 'touchstart') { 
            e.preventDefault(); 
            touchStartX = e.touches[0].clientX; 
            touchStartY = e.touches[0].clientY; 
        } else { 
            touchStartX = e.clientX; 
            touchStartY = e.clientY; 
        }
        
        // åº§æ¨™è¨ˆç®—
        let rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width;
        let scaleY = canvas.height / rect.height;
        cx = (touchStartX - rect.left) * scaleX;
        cy = (touchStartY - rect.top) * scaleY;

        if (gameState === 'nest') {
            // â˜…ãƒãƒ ã‚¹ã‚¿ãƒ¼ã®æ´ã¿åˆ¤å®š
            for(let h of nestHamsters) {
                let dx = h.x - cx; 
                let dy = (h.y - h.size/2) - cy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < h.size) {
                    draggedHamster = h;
                    h.isDragging = true;
                    h.isThrown = false;
                    h.vx = 0; h.vy = 0;
                    dragOffsetX = h.x - cx;
                    dragOffsetY = (h.y - h.size/2) - cy;
                    lastDragX = cx; lastDragY = cy;
                    return; // ãƒãƒ ã‚¹ã‚¿ãƒ¼ã‚’æ´ã‚“ã ã‚‰ç¨®åˆ¤å®šã¯ã—ãªã„
                }
            }

            // ç¨®ã®ç‰©ç†ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆæ—¢å­˜ï¼‰
            for(let s of nestSeeds) {
                let dx = s.x - cx; let dy = s.y - cy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 100) {
                    let force = (100 - dist) * 0.2; s.wakeUp();
                    s.vx += (dx/dist) * force + (Math.random()-0.5)*5; s.vy -= force * 0.5 + Math.random()*5;
                }
            }
        }
        else if (gameState === 'playing') player.jump();
    }

    // â˜…è¿½åŠ : ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ç§»å‹•å‡¦ç†
    function handleInputMove(e) {
        if (gameState !== 'nest' || !draggedHamster) return;
        e.preventDefault();

        let cx, cy;
        if(e.type === 'touchmove') {
            cx = e.touches[0].clientX;
            cy = e.touches[0].clientY;
        } else {
            cx = e.clientX;
            cy = e.clientY;
        }

        let rect = canvas.getBoundingClientRect();
        let scaleX = canvas.width / rect.width;
        let scaleY = canvas.height / rect.height;
        let gameX = (cx - rect.left) * scaleX;
        let gameY = (cy - rect.top) * scaleY;

        // ä½ç½®æ›´æ–°
        draggedHamster.x = gameX + dragOffsetX;
        draggedHamster.y = gameY + dragOffsetY + draggedHamster.size/2; // è¶³å…ƒåŸºæº–ã«æˆ»ã™

        // æŠ•ã’ã‚‹é€Ÿåº¦ã®è¨ˆç®— (ç°¡æ˜“çš„ãªå·®åˆ†)
        dragVelocityX = (gameX - lastDragX) * 0.5;
        dragVelocityY = (gameY - lastDragY) * 0.5;
        lastDragX = gameX;
        lastDragY = gameY;
    }

    function handleInputEnd(e) {
        // â˜…ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ï¼ˆæŠ•ã’ã‚‹ï¼‰
        if (gameState === 'nest' && draggedHamster) {
            draggedHamster.isDragging = false;
            draggedHamster.isThrown = true;
            // é€Ÿåº¦é©ç”¨ï¼ˆåˆ¶é™ä»˜ãï¼‰
            draggedHamster.vx = Math.max(-20, Math.min(20, dragVelocityX));
            draggedHamster.vy = Math.max(-20, Math.min(20, dragVelocityY));
            draggedHamster = null;
            return;
        }

        if (gameState !== 'playing') return;
        let touchEndX = 0; let touchEndY = 0;
        if(e.type === 'touchend') { touchEndX = e.changedTouches[0].clientX; touchEndY = e.changedTouches[0].clientY; }
        else { touchEndX = e.clientX; touchEndY = e.clientY; }
        let diffX = touchEndX - touchStartX; let diffY = touchEndY - touchStartY;
        if (diffX < -50 && Math.abs(diffX) > Math.abs(diffY)) pauseGame();
    }

    window.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove); // è¿½åŠ 
    window.addEventListener('mouseup', handleInputEnd);
    
    window.addEventListener('touchstart', handleInputStart, {passive: false});
    window.addEventListener('touchmove', handleInputMove, {passive: false}); // è¿½åŠ 
    window.addEventListener('touchend', handleInputEnd);

    function updateSeedDisplay() {
        let currentMax = getMaxSeedCapacity();
        document.getElementById('seedCount').innerText = `Seeds: ${seedsCollected} / ${currentMax}`;
    }

    function pauseGame() { if (gameState !== 'playing') return; gameState = 'paused'; document.getElementById('pauseModal').style.display = 'block'; }
    
    function confirmGoHome() { 
        gameState = 'nest'; 
        let log = processTimePassage(seedsCollected, followers.length);
        document.getElementById('logContent').innerHTML = log.join('<br>');
        document.getElementById('logModal').style.display = 'block';
        document.getElementById('pauseModal').style.display = 'none'; 
        initNest(); 
    }
    function closeLog() { document.getElementById('logModal').style.display = 'none'; }
    function cancelGoHome() { gameState = 'playing'; document.getElementById('pauseModal').style.display = 'none'; gameLoop(); }
    
    function gameOver() {
        gameState = 'gameover'; 
        saveData();
        const modal = document.getElementById('gameOverModal');
        const text = document.getElementById('overlayText');
        text.innerHTML = `<h2>Game Over</h2><p>Distance: ${Math.floor(score / 10)}m</p><p>ç¨®ãƒ­ã‚¹ãƒˆ: ${seedsCollected}</p><p style="font-size:14px; color:#aaa;">ä»²é–“ã¨ã¯ãã‚Œã¦ã—ã¾ã£ãŸ...</p>`;
        modal.style.display = 'block';
    }
    function resetGame(initialFollowersCount = 0) {
        gameState = 'playing';
        document.getElementById('gameOverModal').style.display = 'none'; document.getElementById('pauseModal').style.display = 'none'; document.getElementById('instruction').style.display = 'none';
        platforms = []; seeds = []; collectibles = []; followers = []; detachedFriends = []; playerHistory = [];
        player.x = 150; player.y = canvas.height / 2; player.width = 68; player.height = 68; player.dy = 0; player.jumpCount = 0; player.color = '#ff3f34';
        // â˜…ä¿®æ­£ï¼šåˆæœŸå±¥æ­´ã‚’æ­£ã—ãåŸ‹ã‚ã‚‹
        for(let i=0; i<initialFollowersCount; i++){ 
            followers.push({}); 
            for(let j=0; j<15; j++) playerHistory.push({footY: player.y + player.height, isGrounded:true, jumpCount:0}); 
        }
        spawnFriendFlag = false; nextFriendScoreTarget = 1000; seedsCollected = 0; 
        updateSeedDisplay();
        platforms.push(new SlopePlatform(0, canvas.height / 2 + 100, canvas.width, 0));
        score = 0; document.getElementById('score').innerText = 'Distance: 0m';
        gameLoop();
    }
</script>
</body>
</html>
